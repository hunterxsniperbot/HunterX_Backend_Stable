import { JWT } from 'google-auth-library';
import fs from 'fs';
import { getJson } from './http.js';

const SHEET_ID = process.env.GOOGLE_SHEETS_ID || '';

// Soporte MULTI-forma de credenciales:
//  A) GOOGLE_SA_JSON_PATH -> ruta a archivo JSON completo
//  B) GOOGLE_SA_JSON      -> contenido JSON pegado en la env (string)
//  C) GOOGLE_SA_EMAIL + GOOGLE_SA_PRIVATE_KEY (con \n escapados)
const SA_JSON_PATH = process.env.GOOGLE_SA_JSON_PATH || '';
const SA_JSON_STR  = process.env.GOOGLE_SA_JSON || '';
const SA_EMAIL     = process.env.GOOGLE_SA_EMAIL || '';
const SA_KEY_RAW   = process.env.GOOGLE_SA_PRIVATE_KEY || '';

function loadSaFromJsonPath(path){
  try {
    // Node ESM no tiene __dirname por defecto; usamos import.meta.url si hiciera falta,
    // pero acá asumimos que el path viene absoluto o relativo al cwd.
    if (!fs.existsSync(path)) return null;
    const raw = fs.readFileSync(path, 'utf8');
    return JSON.parse(raw);
  } catch { return null; }
}

function loadSaFromJsonString(s){
  try { return JSON.parse(s); } catch { return null; }
}

function loadSaFromSplitEnv(){
  if (!SA_EMAIL || !SA_KEY_RAW) return null;
  return {
    client_email: SA_EMAIL,
    private_key: SA_KEY_RAW.replace(/\\n/g, '\n'),
  };
}

function resolveSa(){
  // Prioridad: archivo -> string -> split env
  if (SA_JSON_PATH) {
    const a = loadSaFromJsonPath(SA_JSON_PATH);
    if (a?.client_email && a?.private_key) return a;
  }
  if (SA_JSON_STR) {
    const a = loadSaFromJsonString(SA_JSON_STR);
    if (a?.client_email && a?.private_key) return a;
  }
  const a = loadSaFromSplitEnv();
  if (a?.client_email && a?.private_key) return a;
  throw new Error('Service Account de Google Sheets no configurado (usa GOOGLE_SA_JSON_PATH o GOOGLE_SA_JSON o GOOGLE_SA_EMAIL/GOOGLE_SA_PRIVATE_KEY)');
}

async function authToken(){
  if (!SHEET_ID) throw new Error('GOOGLE_SHEETS_ID no configurado');
  const sa = resolveSa();
  const client = new JWT({
    email: sa.client_email,
    key: sa.private_key,
    scopes: ['https://www.googleapis.com/auth/spreadsheets.readonly'],
  });
  const { access_token } = await client.authorize();
  if (!access_token) throw new Error('No se pudo obtener token de Sheets');
  return access_token;
}

// Lee una pestaña completa y devuelve [{col:val,...}, ...]
export async function readRowsCached_old(tabName){
  const token = await authToken();
  const url = `https://sheets.googleapis.com/v4/spreadsheets/${SHEET_ID}/values/${encodeURIComponent(tabName)}?majorDimension=ROWS`;
  const j = await getJson(url, { headers:{ Authorization: `Bearer ${token}` }, timeout: 12000 });
  const rows = j?.values || [];
  if (!rows.length) return [];
  const header = rows[0].map(s => String(s||'').trim());
  const out = [];
  for (let i=1;i<rows.length;i++){
    const r = rows[i];
    const obj = {};
    for (let c=0;c<header.length;c++) obj[header[c]] = r[c];
    out.push(obj);
  }
  return out;
}

// Para que funcione también "import sheets from './sheets.js'"
const _default = { readRows };
export default _default;

// --- Cached readRows para no golpear Sheets tan seguido ---
const _rowsCache = new Map(); // tab -> { t, rows }
const ROWS_TTL_MS = 7000;

export async function readRowsCached_old(tab){
  const hit = _rowsCache.get(tab);
  if (hit && (Date.now() - hit.t) < ROWS_TTL_MS) return hit.rows;
  const rows = await readRowsCached(tab);
  _rowsCache.set(tab, { t: Date.now(), rows });
  return rows;
}

// Canonical cached reader (TTL ~7s)
export async function readRowsCached(tab){
  if (!globalThis.__sheetsCache) globalThis.__sheetsCache = new Map(); // persistente por proceso
  const cache = globalThis.__sheetsCache; // tab -> { t, rows }
  const TTL = 7000;
  const hit = cache.get(tab);
  if (hit && (Date.now() - hit.t) < TTL) return hit.rows;
  const rows = await readRows(tab); // <-- importante: llama a readRows, NO a sí misma
  cache.set(tab, { t: Date.now(), rows });
  return rows;
}

// Canonical cached reader (TTL ~7s)
export async function readRowsCached(tab){
  if (!globalThis.__sheetsCache) globalThis.__sheetsCache = new Map(); // proceso-local
  const cache = globalThis.__sheetsCache; // tab -> { t, rows }
  const TTL = 7000;
  const hit = cache.get(tab);
  if (hit && (Date.now() - hit.t) < TTL) return hit.rows;
  const rows = await readRows(tab); // <- IMPORTANTE: llama a readRows, NO a sí misma
  cache.set(tab, { t: Date.now(), rows });
  return rows;
}

// --- Canonical cached reader (TTL 7000 ms) ---
export async function readRowsCached(tab){
  if (!globalThis.__sheetsCache) globalThis.__sheetsCache = new Map(); // proceso-local
  const cache = globalThis.__sheetsCache; // tab -> { t, rows }
  const TTL = 7000;
  const hit = cache.get(tab);
  if (hit && (Date.now() - hit.t) < TTL) return hit.rows;
  const rows = await readRows(tab); // Importante: llama a readRows, NO a sí misma
  cache.set(tab, { t: Date.now(), rows });
  return rows;
}
