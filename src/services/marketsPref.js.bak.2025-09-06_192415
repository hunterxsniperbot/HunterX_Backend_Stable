import * as orig from './markets.js';

// Prioridad editable: gecko,raydium,dexscreener
const ORDER = (process.env.MARKETS_ORDER || 'gecko,raydium,dexscreener')
  .split(',').map(s => s.trim().toLowerCase());

function scoreSource(s){
  const i = ORDER.indexOf(String(s||'').toLowerCase());
  return i === -1 ? 999 : i;
}

async function safeCall(fn, ctx, opts){
  if (typeof fn !== 'function') return [];
  try {
    const r = await fn.call(ctx, opts||{});
    return Array.isArray(r) ? r : [];
  } catch { return []; }
}

// Intenta varias formas de export del markets original
async function getFromOrig(opts){
  // candidatos típicos: named, default.getSolanaPairs, default (fn), getPairs
  const cands = [
    orig.getSolanaPairs,
    orig.default && orig.default.getSolanaPairs,
    (typeof orig.default === 'function' ? orig.default : null),
    orig.getPairs,
  ].filter(Boolean);

  for (const fn of cands){
    const r = await safeCall(fn, (orig.default||orig), opts);
    if (r.length || Array.isArray(r)) return r; // devolver incluso vacío
  }
  return [];
}

async function fetchJson(url, { timeoutMs=2500 } = {}){
  const ac = new AbortController();
  const t = setTimeout(()=>ac.abort('timeout'), timeoutMs);
  try{
    const r = await fetch(url, {
      headers: { 'user-agent': 'Mozilla/5.0' },
      signal: ac.signal
    });
    return await r.json();
  }catch{ return null; }
  finally{ clearTimeout(t); }
}

// Fallback mínimo a GeckoTerminal
async function getFromGecko(limit=20){
  const out = [];
  let page = 1;
  while (out.length < limit && page <= 3){
    const url = `https://api.geckoterminal.com/api/v2/networks/solana/pools?page=${page}`;
    const j = await fetchJson(url, { timeoutMs: 3000 });
    const arr = j?.data || [];
    for (const it of arr){
      const a = it?.attributes || {};
      const name = a.name || '';
      const [baseSymbol='?', quoteSymbol='?'] = name.split('/');
      let pairAddress = null;
      if (typeof it?.id === 'string' && it.id.startsWith('solana_')){
        pairAddress = it.id.slice('solana_'.length);
      }
      const basePriceUsd = a.base_token_price_usd ? Number(a.base_token_price_usd) : null;
      const liqUsd = a.reserve_in_usd ?? a.reserve_usd ?? a.total_reserve_in_usd ?? null;
      const fdvUsd = a.fdv_usd ?? a.fdv ?? null;

      out.push({
        source: 'gecko',
        dexId: 'unknown',
        pairAddress,
        baseSymbol,
        quoteSymbol,
        priceUsd: basePriceUsd,
        liquidityUsd: liqUsd != null ? Number(liqUsd) : null,
        fdvUsd: fdvUsd != null ? Number(fdvUsd) : null,
        gecko: { raw: a },
      });
      if (out.length >= limit) break;
    }
    page++;
  }
  return out;
}

export async function getSolanaPairs(opts = {}) {
  const limit = Number(opts.limit || 20);

  // 1) Intentar markets.js original (como venga exportado)
  let arr = await getFromOrig({ limit }).catch(()=>[]);

  // 2) Si no trajo nada, fallback a Gecko
  if (!Array.isArray(arr) || arr.length === 0) {
    arr = await getFromGecko(limit).catch(()=>[]);
  }

  // 3) Ordenar por fuente preferida + dedupe
  const seen = new Set();
  const sorted = (arr || []).sort((a,b) => scoreSource(a.source) - scoreSource(b.source));
  const out = [];
  for (const p of sorted) {
    const key = p.pairAddress || `${p.baseSymbol}|${p.quoteSymbol}|${p.dexId||p.source}`;
    if (seen.has(key)) continue;
    seen.add(key);
    out.push(p);
    if (out.length >= limit) break;
  }
  return out;
}

export default { getSolanaPairs };
