// ESM
import axios from 'axios';

// ===== Config desde env (con defaults sensatos) =====
const ORDER = (process.env.PRICES_ORDER || 'JUPITER,DEXSCREENER,BIRDEYE,RAYDIUM,COINGECKO,CMC')
  .split(',').map(s => s.trim().toUpperCase()).filter(Boolean);

const PRICES_TIMEOUT_MS   = +(process.env.PRICES_TIMEOUT_MS   || 5000);
const DEADLINE_MS         = +(process.env.prices_deadline_ms  || 1500);
const HEDGED_DELAY_MS     = +(process.env.hedged_delay_ms     || 120);
const TTL_MS              = +(process.env.PRICES_TTL_MS       || 15000);
const NEG_TTL_MS          = +(process.env.negative_ttl_ms     || 5000);

const CB_FAIL_THRESHOLD   = +(process.env.CB_FAIL_THRESHOLD   || 5);
const CB_WINDOW_S         = +(process.env.CB_WINDOW_S         || 60);
const CB_COOLDOWN_S       = +(process.env.CB_COOLDOWN_S       || 60);

const BIRDEYE_API_KEY     = process.env.BIRDEYE_API_KEY || '';
const CMC_API_KEY         = process.env.CMC_API_KEY     || '';
const COINGECKO_API_KEY   = process.env.COINGECKO_API_KEY || ''; // opcional

// Mints conocidos
const MINT_SOL  = 'So11111111111111111111111111111111111111112';
const MINT_USDC = 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v';
const WELL_KNOWN = Object.freeze({
  [MINT_SOL]: 'SOL',
  [MINT_USDC]: 'USDC',
});

// ===== Infra de resiliencia/cache =====
const priceCache = new Map(); // mint -> { price, source, ts }
const negCache   = new Map(); // key(provider|mint) -> ts
const cbState    = new Map(); // provider -> { fails:[], openUntil:ts }

function now() { return Date.now(); }
function negKey(provider, mint) { return provider + '|' + mint; }

function setPriceCache(mint, price, source) {
  priceCache.set(mint, { price, source, ts: now() });
}
function getPriceCache(mint) {
  const e = priceCache.get(mint);
  if (!e) return null;
  if (now() - e.ts > TTL_MS) return null;
  return e;
}
function setNegCache(provider, mint) {
  negCache.set(negKey(provider, mint), now());
}
function canUseProvider(provider, mint) {
  const ts = negCache.get(negKey(provider, mint));
  if (!ts) return true;
  return (now() - ts) > NEG_TTL_MS;
}
function recordFail(provider) {
  const s = cbState.get(provider) || { fails: [], openUntil: 0 };
  const t = now();
  // purge window
  s.fails = s.fails.filter(x => (t - x) < CB_WINDOW_S*1000);
  s.fails.push(t);
  if (s.fails.length >= CB_FAIL_THRESHOLD) {
    s.openUntil = t + CB_COOLDOWN_S*1000;
  }
  cbState.set(provider, s);
}
function recordSuccess(provider) {
  cbState.set(provider, { fails: [], openUntil: 0 });
}
function cbOpen(provider) {
  const s = cbState.get(provider);
  return s && s.openUntil && now() < s.openUntil;
}

// ===== Helpers =====
function httpGet(url, { headers = {}, timeout = PRICES_TIMEOUT_MS } = {}) {
  return axios.get(url, { headers, timeout, validateStatus: s => s>=200 && s<500 })
    .then(r => r.data)
    .catch(() => null);
}

function withTimeout(promise, ms) {
  return new Promise(resolve => {
    const to = setTimeout(() => resolve(null), ms);
    promise.then(v => { clearTimeout(to); resolve(v); })
           .catch(() => { clearTimeout(to); resolve(null); });
  });
}

function parseFloatSafe(x) {
  const n = +x;
  return Number.isFinite(n) && n>0 ? n : null;
}

function isMint(m) { return typeof m === 'string' && m.length >= 32; }

// ====== Proveedores ======
// 1) Jupiter: https://price.jup.ag/v6/price?ids=<mint|symbol>
async function pJUPITER(mint) {
  const id = WELL_KNOWN[mint] || mint;
  const url = `https://price.jup.ag/v6/price?ids=${encodeURIComponent(id)}`;
  const data = await httpGet(url);
  const price = data?.data?.[id]?.price ?? data?.data?.[mint]?.price;
  const v = parseFloatSafe(price);
  return v ? { source: 'JUPITER', price: v } : null;
}

// 2) DexScreener: https://api.dexscreener.com/latest/dex/tokens/<mint>
async function pDEXSCREENER(mint) {
  if (!isMint(mint)) return null;
  const url = `https://api.dexscreener.com/latest/dex/tokens/${mint}`;
  const data = await httpGet(url);
  const pairs = data?.pairs;
  if (!Array.isArray(pairs) || pairs.length===0) return null;
  // elegir el par con mayor liquidez que tenga priceUsd
  let best = null;
  for (const p of pairs) {
    const pu = parseFloatSafe(p?.priceUsd);
    const liq = parseFloatSafe(p?.liquidity?.usd);
    if (!pu) continue;
    if (!best || (liq||0) > (best.liq||0)) best = { price: pu, liq };
  }
  return best ? { source: 'DEXSCREENER', price: best.price } : null;
}

// 3) Birdeye: https://public-api.birdeye.so/public/price?address=<mint>
async function pBIRDEYE(mint) {
  if (!BIRDEYE_API_KEY) return null;
  if (!isMint(mint)) return null;
  const url = `https://public-api.birdeye.so/public/price?address=${mint}`;
  const data = await httpGet(url, { headers: { 'X-API-KEY': BIRDEYE_API_KEY } });
  const v = parseFloatSafe(data?.data?.value);
  return v ? { source: 'BIRDEYE', price: v } : null;
}

// 4) Raydium (limitado): API expone símbolos, no mints arbitrarios.
//    Usamos Raydium sólo para SOL/USDC (mints conocidos).
async function pRAYDIUM(mint) {
  const sym = WELL_KNOWN[mint];
  if (!sym) return null;
  // https://api.raydium.io/v2/main/price?ids=SOL,USDC
  const url = `https://api.raydium.io/v2/main/price?ids=${sym}`;
  const data = await httpGet(url);
  const v = parseFloatSafe(data?.[sym]);
  return v ? { source: 'RAYDIUM', price: v } : null;
}

// 5) CoinGecko: contrato SPL -> precio USD
//    https://api.coingecko.com/api/v3/coins/solana/contract/<mint>
async function pCOINGECKO(mint) {
  if (!isMint(mint)) return null;
  const url = `https://api.coingecko.com/api/v3/coins/solana/contract/${mint}`;
  const headers = COINGECKO_API_KEY ? { 'x-cg-pro-api-key': COINGECKO_API_KEY } : {};
  const data = await httpGet(url, { headers });
  const v = parseFloatSafe(data?.market_data?.current_price?.usd);
  return v ? { source: 'COINGECKO', price: v } : null;
}

// 6) CoinMarketCap (limitado): mejor para SOL/USDC por símbolo
//    https://pro-api.coinmarketcap.com/v2/cryptocurrency/quotes/latest?symbol=SOL
async function pCMC(mint) {
  if (!CMC_API_KEY) return null;
  const sym = WELL_KNOWN[mint];
  if (!sym) return null;
  const url = `https://pro-api.coinmarketcap.com/v2/cryptocurrency/quotes/latest?symbol=${sym}`;
  const data = await httpGet(url, { headers: { 'X-CMC_PRO_API_KEY': CMC_API_KEY } });
  const quote = data?.data?.[sym]?.[0]?.quote?.USD?.price;
  const v = parseFloatSafe(quote);
  return v ? { source: 'CMC', price: v } : null;
}

// Mapa de proveedores
const PROVIDERS = {
  JUPITER:     pJUPITER,
  DEXSCREENER: pDEXSCREENER,
  BIRDEYE:     pBIRDEYE,
  RAYDIUM:     pRAYDIUM,
  COINGECKO:   pCOINGECKO,
  CMC:         pCMC,
};

// ===== Ejecutor con hedged + CB + negative cache =====
async function callProvider(providerName, mint) {
  const fn = PROVIDERS[providerName];
  if (!fn) return null;
  if (cbOpen(providerName)) return null;
  if (!canUseProvider(providerName, mint)) return null;

  const res = await withTimeout(fn(mint), PRICES_TIMEOUT_MS);
  if (res && res.price) {
    recordSuccess(providerName);
    return res;
  } else {
    recordFail(providerName);
    setNegCache(providerName, mint);
    return null;
  }
}

// Lanza proveedores escalonados (hedged). Devuelve el 1º válido.
async function hedgedRace(mint, providers) {
  const startedAt = now();
  const tasks = [];
  for (let i = 0; i < providers.length; i++) {
    const name = providers[i];
    const delay = i * HEDGED_DELAY_MS;
    tasks.push(new Promise(resolve => {
      setTimeout(async () => {
        const rem = DEADLINE_MS - (now() - startedAt);
        if (rem <= 0) return resolve(null);
        const r = await withTimeout(callProvider(name, mint), rem);
        resolve(r?.price ? r : null);
      }, delay);
    }));
  }
  // carrera por el primero válido o null si todos fallan/timeout
  return Promise.race(tasks.map(p => p.then(v => v || null)))
    .then(async first => {
      if (first && first.price) return first;
      // si ninguno ganó, esperar al resto hasta DEADLINE total
      const rem = Math.max(0, DEADLINE_MS - (now() - startedAt));
      const settled = await withTimeout(Promise.allSettled(tasks), rem);
      if (!settled) return null;
      for (const s of settled) {
        const v = s?.value;
        if (v && v.price) return v;
      }
      return null;
    });
}

// ===== API pública =====
export async function getPriceUSD(mint) {
  // ── SHORTCUT ESTABLE: USDC siempre 1.0 ─────────────────────────────────
  // Evita lecturas erróneas si el par de referencia no es USD
  const USDC_MINTS = new Set([
    '''EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v'''
    // '''Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB'''  // (Opcional) tratar USDT como 1.0
  ]);
  if (USDC_MINTS.has(mint)) {
    return { source: '''STATIC_USDC''', price: 1.0, cached: false };
  }
  if (!mint) return null;

  // 1) cache
  const cached = getPriceCache(mint);
  if (cached) return { source: cached.source, price: cached.price, cached: true };

  // 2) providers en orden (filtrando desconocidos)
  const providers = ORDER.filter(n => !!PROVIDERS[n]);

  // 3) carrera hedged con deadline
  const res = await hedgedRace(mint, providers);

  // 4) set cache si lo logramos
  if (res && res.price) {
    setPriceCache(mint, res.price, res.source);
    return { source: res.source, price: res.price, cached: false };
  }

  // 5) último recurso: devolver cache vencido si existe (mejor que null)
  const stale = priceCache.get(mint);
  if (stale) {
    return { source: stale.source, price: stale.price, cached: true, stale: true };
  }

  // 6) sin datos
  return null;
}

// atajo para SOL y USDC si necesitás
export async function getSOLPriceUSD()  { return getPriceUSD(MINT_SOL);  }
export async function getUSDCPriceUSD() { return getPriceUSD(MINT_USDC); }

export default { getPriceUSD, getSOLPriceUSD, getUSDCPriceUSD };
