// src/commands/health.js â€” Health â€œvivoâ€ con auto-refresh adaptativo (HTML)
const OK  = 'âœ…';
const BAD = 'âŒ';

const I = {
  infra: 'ğŸ›°ï¸',
  tg: 'ğŸ¤–',
  qn: 'ğŸ”Œ',
  phantom: 'ğŸªª',
  supabase: 'ğŸ—ƒï¸',
  sheets: 'ğŸ“„',
  render: 'ğŸš€',

  data: 'ğŸ“¡',
  dexscreener: 'ğŸ“Š',
  birdeye: 'ğŸ¦…',
  tokensniffer: 'ğŸ•µï¸',
  whale: 'ğŸ‹',
  tf: 'ğŸ§ ',
  solscan: 'ğŸ”¦',
  jupiter: 'ğŸª',
  raydium: 'ğŸ’ ',
  gecko: 'ğŸ¦',
  cmc: 'ğŸª™',
  discord: 'ğŸ’¬',
};

function esc(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
const sleep = (ms)=> new Promise(r=>setTimeout(r,ms));

// fetch con timeout corto
async function ping(url, { method='GET', headers={}, body, timeoutMs=2500 } = {}) {
  try {
    const res = await fetch(url, { method, headers, body, signal: AbortSignal.timeout(timeoutMs) });
    return res.ok;
  } catch { return false; }
}

// --------- PROBES â€œrealesâ€ (o heurÃ­sticos si falta API key) ---------
async function checkQuickNode() {
  const url = process.env.QUICKNODE_HTTP || process.env.QUICKNODE_RPC_URL || process.env.RPC_URL;
  if (!url) return false;
  try {
    const res = await fetch(url, {
      method: 'POST',
      headers: { 'content-type':'application/json' },
      body: JSON.stringify({ jsonrpc:'2.0', id:1, method:'getHealth' }),
      signal: AbortSignal.timeout(2500),
    });
    if (!res.ok) return false;
    const j = await res.json().catch(()=>null);
    return j?.result === 'ok' || !!j;
  } catch { return false; }
}

async function checkPhantom(bot) { return !!bot._phantomClient; }

async function checkSupabase() {
  const url = process.env.SUPABASE_URL;
  const key = process.env.SUPABASE_ANON_KEY;
  if (!url || !key) return false;
  return ping(`${url.replace(/\/+$/,'')}/auth/v1/health`, { headers: { apikey: key }, timeoutMs: 2500 });
}

async function checkSheets() {
  const id = process.env.GOOGLE_SHEETS_ID || process.env.SHEETS_ID || process.env.GSHEET_ID;
  const svc = process.env.GOOGLE_SERVICE_ACCOUNT_EMAIL && process.env.GOOGLE_PRIVATE_KEY;
  return !!(id && svc);
}

async function checkRender() { return !!(process.env.RENDER || process.env.RENDER_EXTERNAL_URL); }

// --------- Fuentes de datos ---------
async function checkDexScreener() { return ping('https://api.dexscreener.com/latest/dex/search?q=sol', { timeoutMs: 2500 }); }
async function checkBirdeye() {
  const key = process.env.BIRDEYE_API_KEY || process.env.BIRD_EYE_API_KEY;
  if (!key) return false;
  return ping('https://public-api.birdeye.so/defi/price?address=So11111111111111111111111111111111111111112',
              { headers: { 'X-API-KEY': key }, timeoutMs: 2500 });
}
async function checkTokenSniffer() { return ping('https://tokensniffer.com', { timeoutMs: 2500 }); }
async function checkWhaleAlert() {
  const key = process.env.WHALE_ALERT_API_KEY || process.env.WHALEALERT_API_KEY;
  if (!key) return false;
  return ping(`https://api.whale-alert.io/v1/status?api_key=${encodeURIComponent(key)}`, { timeoutMs: 2500 });
}
async function checkTF() {
  try {
    const tf = await import('@tensorflow/tfjs-node').catch(()=>null) || await import('@tensorflow/tfjs').catch(()=>null);
    return !!tf;
  } catch { return false; }
}
async function checkSolscan() { return ping('https://public-api.solscan.io/chaininfo', { timeoutMs: 2500 }); }
async function checkJupiter() { return ping('https://price.jup.ag/v4/price?ids=SOL', { timeoutMs: 2500 }); }
async function checkRaydium() { return ping('https://api.raydium.io/pairs', { timeoutMs: 2500 }); }
async function checkGecko()   { return ping('https://api.coingecko.com/api/v3/ping', { timeoutMs: 2500 }); }
async function checkCMC() {
  const key = process.env.CMC_API_KEY || process.env.COINMARKETCAP_API_KEY;
  if (!key) return false;
  return ping('https://pro-api.coinmarketcap.com/v1/key/info', {
    headers: { 'X-CMC_PRO_API_KEY': key }, timeoutMs: 2500
  });
}
async function checkDiscord() { return !!process.env.DISCORD_TOKEN; }

// --------- Renderizador del panel ---------
async function snapshot(bot) {
  const tgMode = 'POLLING';
  const [
    qn, ph, sb, sh, rn,
    dx, be, ts, wa, tf,
    ss, jp, ry, cg, cmc, dc
  ] = await Promise.all([
    checkQuickNode(),
    checkPhantom(bot),
    checkSupabase(),
    checkSheets(),
    checkRender(),

    checkDexScreener(),
    checkBirdeye(),
    checkTokenSniffer(),
    checkWhaleAlert(),
    checkTF(),

    checkSolscan(),
    checkJupiter(),
    checkRaydium(),
    checkGecko(),
    checkCMC(),
    checkDiscord(),
  ]);

  const lines = [
    `<b>${I.infra} Estado HunterX</b>`,
    '',
    '<b>Infraestructura</b>',
    `${I.tg} TG mode: <b>${esc(tgMode)}</b>`,
    `${I.qn} QuickNode: ${qn?OK:BAD}`,
    `${I.phantom} Phantom: ${ph?OK:BAD}`,
    `${I.supabase} Supabase: ${sb?OK:BAD}`,
    `${I.sheets} Google Sheets: ${sh?OK:BAD}`,
    `${I.render} Render: ${rn?OK:BAD}`,
    '',
    '<b>Fuentes de datos</b>',
    `${I.dexscreener} DexScreener: ${dx?OK:BAD}`,
    `${I.birdeye} Birdeye: ${be?OK:BAD}`,
    `${I.tokensniffer} TokenSniffer: ${ts?OK:BAD}`,
    `${I.whale} Whale Alert: ${wa?OK:BAD}`,
    `${I.tf} TensorFlow IA: ${tf?OK:BAD}`,
    `${I.solscan} Solscan: ${ss?OK:BAD}`,
    `${I.jupiter} Jupiter: ${jp?OK:BAD}`,
    `${I.raydium} Raydium: ${ry?OK:BAD}`,
    `${I.gecko} CoinGecko: ${cg?OK:BAD}`,
    `${I.cmc} CoinMarketCap: ${cmc?OK:BAD}`,
    `${I.discord} Discord: ${dc?OK:BAD}`,
  ];
  return lines.join('\n');
}

// ---------- Scheduler ADAPTATIVO (indefinido, liviano) -------------
function jitter(ms) {
  // +/-10% para evitar sincronizaciÃ³n
  const f = 1 + (Math.random()*0.2 - 0.1);
  return Math.round(ms * f);
}

function nextDelay({ prevMs, changed, errorCount, baseMs, minMs=5000, maxIdleMs=60000, maxErrMs=120000 }) {
  if (errorCount > 0) {
    // backoff exponencial con tope
    const doubled = Math.min(maxErrMs, Math.max(baseMs, prevMs * 2));
    return jitter(doubled);
  }
  if (changed) {
    // hubo cambios â†’ volvemos al base
    return jitter(Math.max(minMs, baseMs));
  }
  // sin cambios â†’ crecemos suave hasta 60s
  const grown = Math.min(maxIdleMs, Math.round(prevMs + Math.max(2000, baseMs * 0.5)));
  return jitter(Math.max(minMs, grown));
}

// === HunterX: helpers de infraestructura ===
import { getConnection, isValidSolAddress, getSolBalance } from '../services/solana.js';

async function buildInfraSection(){
  // QuickNode (RPC Solana)
  const quickNodeOk = await (async()=>{
    try { await getConnection(); return 'âœ…'; } catch { return 'âŒ'; }
  })();

  // Phantom (balance) â€” si hay address vÃ¡lida
  let phantomLine = 'âŒ';
  try{
    const addr = process.env.PHANTOM_ADDRESS || '';
    if (isValidSolAddress(addr)) {
      const bal = await getSolBalance(addr);          // nÃºmero en SOL
      phantomLine = \`âœ… (\${bal.toFixed(4)} SOL)\`;
    }
  }catch(_) {}

  const sheetsOk = process.env.GOOGLE_SHEETS_ID ? 'âœ…' : 'âŒ';
  const renderOk = 'âŒ';

  // Devuelve bloque HTML listo para pegar en el mensaje
  return [
    '<b>Infraestructura</b>',
    '<pre>',
    'â€¢ TG mode: POLLING',
    \`â€¢ QuickNode: \${quickNodeOk}\`,
    \`â€¢ Phantom: \${phantomLine}\`,
    \`â€¢ Google Sheets: \${sheetsOk}\`,
    \`â€¢ Render: \${renderOk}\`,
    '</pre>',
  ].join('\\n');
}
export default function registerHealth(bot) {
  bot._healthState = bot._healthState || {}; // por uid: {timer, running, prevText, delayMs, errors}
  // /health [seg] | /health once | /health stop
  bot.removeTextListener?.(/^\/health(?:@[\w_]+)?/i);
  bot.onText(/^\/health(?:@[\w_]+)?(?:\s+(stop|once|\d+))?\s*$/i, async (msg, m) => {
    const chatId = msg.chat.id;
    const uid    = String(msg.from.id);
    const arg    = (m && m[1]) ? m[1].toLowerCase() : '';
    const baseSec = (arg && /^\d+$/.test(arg)) ? Number(arg) : 10; // default 10s
    const baseMs  = Math.max(3000, Math.min(60000, baseSec * 1000));

    const st = bot._healthState[uid] = bot._healthState[uid] || { timer:null, running:false, prevText:'', delayMs:baseMs, errors:0 };

    // STOP
    if (arg === 'stop') {
      if (st.timer) { clearTimeout(st.timer); st.timer=null; }
      return bot.sendMessage(chatId, 'â¹ï¸ Auto-refresh detenido.', { parse_mode:'HTML' });
    }

    // ONE-SHOT
    if (arg === 'once') {
      const text = await snapshot(bot);
      return bot.sendMessage(chatId, text, { parse_mode:'HTML' });
    }

    // arranque: primer mensaje
    const first = await snapshot(bot);
    const replyMarkup = {
      inline_keyboard: [[
        { text: `ğŸ”„ base ${Math.round(baseMs/1000)}s`, callback_data: 'health:noop' },
        { text: 'â¹ï¸ Parar', callback_data: 'health:stop' },
      ]]
    };
    const sent = await bot.sendMessage(chatId, first, { parse_mode:'HTML', reply_markup: replyMarkup });
    st.prevText = first;
    st.delayMs  = baseMs;
    st.errors   = 0;

    // cancelar loop previo si hubiera
    if (st.timer) { clearTimeout(st.timer); st.timer=null; }

    // Loop recursivo con setTimeout (permite delay adaptativo)
    const tick = async () => {
      if (st.running) { // anti-reentrancia
        st.timer = setTimeout(tick, jitter(1000));
        return;
      }
      st.running = true;
      let changed = false;
      try {
        const fresh = await snapshot(bot);
        if (fresh !== st.prevText) {
          // editar solo si cambiÃ³
          await bot.editMessageText(fresh, { chat_id: chatId, message_id: sent.message_id, parse_mode:'HTML', reply_markup: replyMarkup });
          st.prevText = fresh;
          changed = true;
        }
        st.errors = 0;
      } catch {
        st.errors = Math.min(st.errors + 1, 10);
      } finally {
        st.running = false;
      }
      st.delayMs = nextDelay({ prevMs: st.delayMs, changed, errorCount: st.errors, baseMs });
      st.timer = setTimeout(tick, st.delayMs);
    };

    st.timer = setTimeout(tick, st.delayMs);
  });

  // callbacks (parar / noop)
  bot.on('callback_query', async (q) => {
    const data = q.data || '';
    if (!/^health:/.test(data)) return;
    const uid = String(q.from.id);
    const st  = bot._healthState?.[uid];
    if (data === 'health:stop') {
      if (st?.timer) { clearTimeout(st.timer); st.timer=null; }
      try { await bot.answerCallbackQuery(q.id, { text: 'Auto-refresh detenido.' }); } catch {}
    } else {
      try { await bot.answerCallbackQuery(q.id); } catch {}
    }
  });

  console.log('âœ… Handler cargado: health.js (live/adaptativo)');
  const __infra = await buildInfraSection();
  if (typeof html !== 'undefined') html = (html ? html + '\n' : '') + __infra;
  if (typeof text !== 'undefined') text = (text ? text + '\n' : '') + __infra;
}
