// ─────────────────────────────────────────────────────────────────────────────
// HUNTER X — /salud | Conexiones activas — HX-A02 — v2025-08-20 (ESM)
// Características:
//   • API-first: intenta leer GET /api/salud y renderizar con formatSummary()
//   • Fallback local: si la API no responde, usa snapshot() propio (HEAD/GET)
//   • UI: mensaje único con botones [🔄 Refrescar] y [AUTO ON/OFF]
//   • Refresh automático con hash anti-parpadeo (no edita si no cambió)
//   • Corte seguro para Telegram (límite 3800 chars)
//   • Sin dependencias adicionales (usa fetch nativo de Node >=18)
// ENV relevantes:
//   - SALUD_REFRESH_MS   (default 12000)   ⇒ periodo de auto-refresh (ms)
//   - API_PORT           (default 3000)    ⇒ puerto local de la API
// Dependencias internas:
//   - ../boot/health_checks.js   ⇒ formatSummary(results)
// Invariantes:
//   - Nunca crashea si la API falla (fallback robusto)
//   - No genera “storm” de edits si el texto no cambió (hash)
// ─────────────────────────────────────────────────────────────────────────────

import { formatSummary } from '../boot/health_checks.js';

const SLOTS = new Map(); // chatId -> { msgId, auto, timer, busy, lastHash }

const EMO = {
  ok: '🟢', warn: '🟡', err: '🔴', head: '🛰️', infra: '🏗️', data: '📚',
  refresh:'🔄', autoOn:'🟢 AUTO', autoOff:'⚪ AUTO'
};

const REFRESH_MS = Number(process.env.SALUD_REFRESH_MS || 12000);
const API_PORT = Number(process.env.API_PORT || 3000);

// ─────────────────────────────────────────────────────────────────────────────
// Helpers genéricos
// ─────────────────────────────────────────────────────────────────────────────
function scoreToLight(s){ return s >= 85 ? EMO.ok : s >= 60 ? EMO.warn : EMO.err; }

function hash(s){ // hash simple para evitar edits innecesarios
  let h=0; for (let i=0;i<s.length;i++) h=((h<<5)-h)+s.charCodeAt(i), h|=0; return String(h);
}

async function fetchJson(url, { timeoutMs=2000, headers={}, method='GET', body=null } = {}) {
  const ac = new AbortController();
  const t = setTimeout(()=>ac.abort('timeout'), timeoutMs);
  try{
    const r = await fetch(url, { method, headers, body, signal: ac.signal });
    const ok = r.ok;
    let json = null, err = null;
    try { json = await r.json(); } catch(e){ err = String(e?.message||e); }
    return { ok, status:r.status, json, error:err, dt:null };
  } catch(e){
    return { ok:false, status:null, json:null, error:String(e?.message||e), dt:null };
  } finally { clearTimeout(t); }
}

function trimForTelegram(text, maxLen = 3800) {
  if (!text || text.length <= maxLen) return text;
  return text.slice(0, maxLen - 20) + '\n\n…(recortado)';
}

async function safeEdit(bot, chatId, messageId, text, kb) {
  // 1) intentar Markdown (summary de /api/salud usa **negritas**)
  try {
    await bot.editMessageText(text, {
      chat_id: chatId,
      message_id: messageId,
      reply_markup: kb,
      parse_mode: 'Markdown',
      disable_web_page_preview: true
    });
    return true;
  } catch {
    // 2) fallback texto plano
    await bot.editMessageText(text.replace(/\*/g,''), {
      chat_id: chatId,
      message_id: messageId,
      reply_markup: kb,
      disable_web_page_preview: true
    });
    return true;
  }
}

async function safeSend(bot, chatId, text, kb) {
  try {
    const m = await bot.sendMessage(chatId, text, {
      reply_markup: kb,
      parse_mode: 'Markdown',
      disable_web_page_preview: true
    });
    return m?.message_id;
  } catch {
    const m = await bot.sendMessage(chatId, text.replace(/\*/g,''), {
      reply_markup: kb,
      disable_web_page_preview: true
    });
    return m?.message_id;
  }
}

// ─────────────────────────────────────────────────────────────────────────────
// API-first: intenta usar la API local /api/salud + formatSummary()
// ─────────────────────────────────────────────────────────────────────────────
async function renderFromApi() {
  const url = `http://127.0.0.1:${API_PORT}/api/salud`;
  const r = await fetchJson(url, { timeoutMs: 1800 });
  if (!r.ok || !Array.isArray(r.json)) return null;
  try {
    const txt = formatSummary(r.json); // devuelve Markdown
    return typeof txt === 'string' ? txt : null;
  } catch {
    return null;
  }
}

// ─────────────────────────────────────────────────────────────────────────────
// Fallback local (snapshot rápido con HEAD/GET cortos)
// ─────────────────────────────────────────────────────────────────────────────
async function safeFetch(url, {timeoutMs=2000, method='GET'}={}){
  const ac = new AbortController();
  const t = setTimeout(()=>ac.abort('timeout'), timeoutMs);
  try{
    const r = await fetch(url, {method, signal: ac.signal});
    return { ok: r.ok, status: r.status };
  }catch(e){ return { ok:false, error:String(e?.message||e) }; }
  finally{ clearTimeout(t); }
}

async function checkHelius(){
  const url = process.env.HELIUS_RPC_URL;
  if (!url) return {name:"Helius", ok:false, score:0, note:"Sin HELIUS_RPC_URL"};
  try{
    const ac = new AbortController();
    const t = setTimeout(()=>ac.abort("timeout"), 2500);
    const r = await fetch(url, {method:"POST", headers:{"content-type":"application/json"}, body: JSON.stringify({jsonrpc:"2.0",id:1,method:"getSlot"}), signal: ac.signal});
    clearTimeout(t);
    const ok = r.ok;
    return {name:"Helius", ok, score: ok?95:0, note: ok? "RPC OK":"HTTP "+r.status};
  }catch(e){ return {name:"Helius", ok:false, score:0, note:String(e?.message||e)} }
}

async function checkQuickNode(){
  const url = process.env.QUICKNODE_URL;
  if (!url) return {name:'QuickNode', ok:false, score:0, note:'Sin QUICKNODE_URL'};
  try{
    const ac = new AbortController();
    const t = setTimeout(()=>ac.abort('timeout'), 2500);
    const r = await fetch(url, {
      method:'POST',
      headers:{'content-type':'application/json'},
      body: JSON.stringify({jsonrpc:'2.0',id:1,method:'getSlot'}),
      signal: ac.signal
    });
    clearTimeout(t);
    const ok = r.ok;
    return {name:'QuickNode', ok, score: ok?95:0, note: ok?'RPC OK':'HTTP '+r.status};
  }catch(e){ return {name:'QuickNode', ok:false, score:0, note:String(e?.message||e)}}
}

async function checkHTTP(name, url){
  const r = await safeFetch(url, {timeoutMs:2000});
  const ok = !!r.ok;
  return { name, ok, score: ok?90:0, note: ok?('HTTP '+r.status): (r.error||('HTTP '+r.status)) };
}

async function snapshot(){
  const infra = [];
  const data  = [];

  // INFRA (best-effort)
  infra.push({name:'TG mode',  ok:true,  score:100, note:'POLLING'});
  infra.push(await checkHelius());
  infra.push(await checkQuickNode());
  const hasPh = !!(process.env.PHANTOM_PK || process.env.PHANTOM_PUBLIC_KEY || process.env.PHANTOM_ADDRESS);
  infra.push({name:'Phantom',  ok:hasPh, score: hasPh?80:0, note: hasPh?'clave presente':'sin clave'});
  const hasSheet = !!process.env.GOOGLE_SHEETS_ID;
  infra.push({name:'Google Sheets', ok:hasSheet, score: hasSheet?70:0, note: hasSheet?'ID presente':'sin ID'});
  const onRender = !!process.env.RENDER;
  infra.push({name:'Render', ok:onRender, score: onRender?60:0, note: onRender?'configurado':'local'});

  // FUENTES (HEAD/GET sintéticos)
  data.push(await checkHTTP('DexScreener', 'https://api.dexscreener.com/latest/dex/tokens/So11111111111111111111111111111111111111112'));
  data.push(await checkHTTP('Birdeye',    'https://public-api.birdeye.so/defi/price?address=So11111111111111111111111111111111111111112'));
  data.push(await checkHTTP('TokenSniffer','https://tokensniffer.com'));
  data.push(await checkHTTP('GoPlus',      'https://api.gopluslabs.io'));
  data.push(await checkHTTP('Whale Alert', 'https://api.whale-alert.io'));
  data.push(await checkHTTP('Solscan',     'https://api.solscan.io/chaininfo'));
  data.push(await checkHTTP('Jupiter',     'https://price.jup.ag/v4/price?ids=SOL'));
  data.push(await checkHTTP('Raydium',     'https://api.raydium.io/pairs?limit=1'));
  data.push(await checkHTTP('CoinGecko',   'https://api.coingecko.com/api/v3/ping'));
  data.push(await checkHTTP('CoinMarketCap','https://pro-api.coinmarketcap.com/v1/cryptocurrency/map'));
  data.push(await checkHTTP('Discord',     'https://discord.com/api/v10'));

  const all = [...infra, ...data];
  const avg = Math.round(all.reduce((a,x)=>a+(x.score||0),0) / Math.max(1, all.length));

  const line = (x)=>{
    const light = scoreToLight(x.score||0);
    const score = (x.score||0).toString().padStart(2,' ');
    return `• ${x.name}: ${light} (${score}) ${x.note?'- '+x.note:''}`;
  };

  const head  = `**${EMO.head} Conexiones activas**`;
  const infraTxt = `**${EMO.infra} Infraestructura**\n` + infra.map(line).join('\n');
  const dataTxt  = `**${EMO.data} Fuentes de datos**\n` + data.map(line).join('\n');
  const global= `\nScore global: ${scoreToLight(avg)} ${avg}/100`;

  return [head, infraTxt, dataTxt, global].join('\n\n');
}

// ─────────────────────────────────────────────────────────────────────────────
// Render principal (API → fallback) + scheduling
// ─────────────────────────────────────────────────────────────────────────────
function buildKb(slot){
  return {
    inline_keyboard: [[
      { text: EMO.refresh+' Refrescar', callback_data: 'salud:refresh' },
      { text: (slot.auto? EMO.autoOn: EMO.autoOff), callback_data: 'salud:auto' }
    ]]
  };
}

async function render(bot, chatId, force=false){
  const slot = SLOTS.get(chatId) || { auto:true };
  SLOTS.set(chatId, slot);
  if (slot.busy) return;
  slot.busy = true;

  try{
    // 1) API-first
    let body = await renderFromApi();
    // 2) Fallback local si API no está
    if (!body) body = await snapshot();

    const kb = buildKb(slot);
    const trimmed = trimForTelegram(body, 3800);
    const sig = hash((trimmed||'') + JSON.stringify(kb) + String(slot.auto));

    if (force || sig !== slot.lastHash) {
      if (!slot.msgId){
        slot.msgId = await safeSend(bot, chatId, trimmed, kb);
      }else{
        await safeEdit(bot, chatId, slot.msgId, trimmed, kb);
      }
      slot.lastHash = sig;
    }
  } catch(e){
    try { await bot.sendMessage(chatId, '❌ Salud: ' + (e?.message||e)); } catch {}
  } finally {
    slot.busy = false;
  }
}

function schedule(bot, chatId){
  const slot = SLOTS.get(chatId);
  if (!slot) return;
  clearTimeout(slot.timer);
  if (slot.auto){
    slot.timer = setTimeout(()=>render(bot, chatId), REFRESH_MS);
  }
}

// ─────────────────────────────────────────────────────────────────────────────
// Registro de comando /salud (alias /health) + callbacks
// ─────────────────────────────────────────────────────────────────────────────
export default function registerSalud(bot){
  // Comandos
  bot.onText(/^\/(salud|health)\b/i, async (msg) => {
    const chatId = msg.chat.id;
    await render(bot, chatId, true);
    schedule(bot, chatId);
  });

  // Botones inline
  bot.on('callback_query', async (q)=>{
    const chatId = q.message?.chat?.id;
    const data   = String(q.data||'');
    if (!chatId || !data.startsWith('salud:')) return;

    const slot = SLOTS.get(chatId) || { auto:true };
    SLOTS.set(chatId, slot);

    if (data === 'salud:refresh'){
      try { await bot.answerCallbackQuery(q.id, { text:'Actualizando…' }); } catch {}
      await render(bot, chatId, true);
      schedule(bot, chatId);
      return;
    }
    if (data === 'salud:auto'){
      slot.auto = !slot.auto;
      try { await bot.answerCallbackQuery(q.id, { text: 'Auto: ' + (slot.auto?'ON':'OFF') }); } catch {}
      await render(bot, chatId, true);
      schedule(bot, chatId);
      return;
    }
  });
}
