import { loadPolicySync } from '../policy.js';
import * as TRADING from '../services/trading.js';
import * as PRICES  from '../services/prices.js';
import * as PHANTOM from '../services/phantom.js';

/* ------------------------------- utilidades ------------------------------- */
const fmtUSD = (n) => (n==null || isNaN(n)) ? '$0.00'
  : '$' + Number(n).toLocaleString('en-US',{minimumFractionDigits:2,maximumFractionDigits:2});
const fmtPct = (n) => (n==null || isNaN(n)) ? '0.0%' : `${n>0?'+':''}${n.toFixed(1)}%`;
const short = (s='', n=4) => s && s.length>10 ? (s.slice(0,4)+'â€¦'+s.slice(-n)) : (s||'');
const mdEsc = (s='') => s.replace(/[_*[\]()~`>#+\-=|{}.!]/g,'\\$&'); // Markdown safe
const hashText = (s) => { let h=0; for (let i=0;i<s.length;i++) h=(h*31+s.charCodeAt(i))|0; return String(h); };

/* Detectar funciones disponibles en trading/phantom que ya tenÃ©s en tu repo */
function pickTrading(deps){ return deps?.trading || TRADING; }
function pickPhantom(deps){ return deps?.phantomClient || PHANTOM; }
function pickPrices(){ return PRICES; }

/* --------------------------- lectura de posiciones ------------------------- */
async function listOpenPositions(T, mode) {
  try {
    if (typeof T.getOpenPositions === 'function')
      return await T.getOpenPositions({ mode }) || [];
    if (typeof T.listOpen === 'function')
      return await T.listOpen({ mode }) || [];
    if (Array.isArray(T.openPositions))
      return T.openPositions.filter(p => !mode || p.mode===mode);
  } catch {}
  return [];
}

async function priceUSD(pr, mint){
  try{
    if(!mint) return null;
    const r = await pr.getPriceUSD(mint);
    return r?.price!=null ? Number(r.price) : (typeof r==='number'?r:null);
  }catch{ return null; }
}

/* ----------------------------- resumenes wallet ---------------------------- */
async function getWalletSummaries(P, T) {
  const out = {
    real: { address:'', invested:0, free:0, total:null },
    demo: { invested:0, free:0, total:null },
  };
  // REAL (Phantom)
  try {
    if (typeof P.getSummaryUSD === 'function') {
      const s = await P.getSummaryUSD(); // {address, investedUSD, freeUSD, totalUSD}
      out.real.address  = s?.address || '';
      out.real.invested = Number(s?.investedUSD || 0);
      out.real.free     = Number(s?.freeUSD || 0);
      out.real.total    = s?.totalUSD!=null ? Number(s.totalUSD) : null;
    }
  } catch {}
  // DEMO
  try {
    if (typeof T.getDemoBank === 'function') {
      const d = await T.getDemoBank(); // {investedUSD, freeUSD}
      out.demo.invested = Number(d?.investedUSD || 0);
      out.demo.free     = Number(d?.freeUSD || 0);
      out.demo.total    = (d?.investedUSD!=null && d?.freeUSD!=null)
        ? Number(d.investedUSD + d.freeUSD) : null;
    }
  } catch {}
  return out;
}

/* ------------------------------- render texto ------------------------------ */
function renderMainCard({mode, counts, wallet, positions}) {
  const lines = [];
  const emojiMode = mode==='real' ? 'ðŸ”µ' : 'ðŸ§ª';
  lines.push(`*${emojiMode} POSICIONES ABIERTAS (${mode.toUpperCase()})*`);
  lines.push('');

  lines.push('ðŸ“± *Posiciones abiertas*');
  lines.push('');
  lines.push(`- DEMO: ${counts.demo}`);
  lines.push(`- REAL: ${counts.real}`);
  lines.push(`- Total: ${counts.total}`);
  lines.push('');

  lines.push('ðŸ’³ *Billetera Phantom (REAL)*');
  lines.push('');
  lines.push(`- Address: ${wallet.real.address ? '`'+wallet.real.address+'`' : 'â€”'}`);
  lines.push(`- Invertido: ${fmtUSD(wallet.real.invested)}`);
  lines.push(`- Libre para sniper: ${fmtUSD(wallet.real.free)}`);
  lines.push(`- Total disponible: ${wallet.real.total!=null ? fmtUSD(wallet.real.total) : 'â€”'}`);
  lines.push('');

  lines.push('ðŸ§ª *Billetera DEMO*');
  lines.push('');
  lines.push(`- Invertido: ${fmtUSD(wallet.demo.invested)}`);
  lines.push(`- Libre para sniper: ${fmtUSD(wallet.demo.free)}`);
  lines.push(`- Total disponible: ${wallet.demo.total!=null ? fmtUSD(wallet.demo.total) : 'â€”'}`);
  lines.push('');

  for (const p of positions) {
    const sym = mdEsc(p.symbol || p.ticker || ('$'+short(p.mint,6)));
    const sign = (p.pnlPct||0) >= 0 ? 'ðŸ“ˆ' : 'ðŸ“‰';
    const pnlAbs = (p.investedUSD||0) * ((p.pnlPct||0)/100);

    lines.push(`ðŸª™ *${sym}*`);
    lines.push(`ðŸ“¥ Precio de entrada: ${p.entryPriceUSD!=null ? p.entryPriceUSD.toFixed(6) : 'â€”'}`);
    lines.push(`ðŸ“¤ Precio actual: ${p.priceUSD!=null ? p.priceUSD.toFixed(6) : 'â€”'}`);
    lines.push(`ðŸ’µ Invertido: ${fmtUSD(p.investedUSD || 0)}`);
    lines.push(`${sign} PnL: ${fmtPct(p.pnlPct || 0)} (${fmtUSD(pnlAbs)})`);
    lines.push(`[ðŸ“Š DexScreener](https://dexscreener.com/solana/${p.mint})  [ðŸ”Ž Solscan](https://solscan.io/token/${p.mint})`);
    lines.push('');
  }
  return lines.join('\n');
}

function buildKeyboard({mode, positions, auto}) {
  const kb = [];
  kb.push([
    { text: 'âŸ³ Refresh', callback_data: 'w|refresh' },
    { text: auto ? 'â± Auto-Refresh ON' : 'â± Auto-Refresh OFF', callback_data: 'w|toggle' },
  ]);
  for (const p of positions) {
    kb.push([
      { text: '25%', callback_data: `w|sell|${mode}|${p.mint}|25` },
      { text: '50%', callback_data: `w|sell|${mode}|${p.mint}|50` },
      { text: '75%', callback_data: `w|sell|${mode}|${p.mint}|75` },
      { text: 'ðŸ’¯',  callback_data: `w|sell|${mode}|${p.mint}|100` },
    ]);
  }
  return { reply_markup: { inline_keyboard: kb }, parse_mode: 'Markdown', disable_web_page_preview: true };
}

/* ---------------------------- estado por chat ------------------------------ */
const SLOTS = new Map(); // chatId -> { msgId, auto, timer, lastHash, mode }

/* ------------------------------ snapshot data ------------------------------ */
async function snapshot(T, P, pr, mode) {
  const [wallet, demoPos, realPos] = await Promise.all([
    getWalletSummaries(P, T),
    listOpenPositions(T, 'demo'),
    listOpenPositions(T, 'real'),
  ]);

  const base = mode==='real' ? realPos : demoPos;
  const enriched = [];
  for (const pos of (base||[])) {
    const mint   = pos.mint || pos.tokenMint || pos.address || '';
    const symbol = pos.symbol || pos.ticker || pos.token || '';
    const entry  = Number(pos.entryPriceUSD || pos.entryPrice || 0);
    const investedUSD = Number(pos.investedUSD || pos.amountUSD || (pos.amount && entry ? pos.amount*entry : 0));
    const px = await priceUSD(pr, mint);
    const pnlPct = (px && entry) ? ((px/entry - 1) * 100) : 0;

    enriched.push({
      mint, symbol, entryPriceUSD: entry || null, priceUSD: px || null, investedUSD, pnlPct,
    });
  }

  enriched.sort((a,b)=> (b.investedUSD||0) - (a.investedUSD||0));
  const top10 = enriched.slice(0,10);

  return {
    counts: { demo: demoPos.length, real: realPos.length, total: demoPos.length + realPos.length },
    wallet, positions: top10
  };
}

/* ---------------------------- handler principal ---------------------------- */
export default function registerWallet(bot, deps = {}) {
  const T  = pickTrading(deps);
  const P  = pickPhantom(deps);
  const pr = pickPrices();

  const CMD = /^\/wallet(?:@.*)?$/i;

  async function render(chatId, force=false) {
    const slot = SLOTS.get(chatId);
    const mode = slot?.mode || (loadPolicySync()?.execution?.mode || 'demo');
    const data = await snapshot(T, P, pr, mode);
    const text = renderMainCard({mode, counts: data.counts, wallet: data.wallet, positions: data.positions});
    const kb   = buildKeyboard({mode, positions: data.positions, auto: slot?.auto ?? true});
    const h    = hashText(text);

    if (!slot?.msgId) {
      const m = await bot.sendMessage(chatId, text, kb).catch(()=>null);
      if (!m) return;
      SLOTS.set(chatId, { msgId: m.message_id, auto: slot?.auto ?? true, timer: slot?.timer, lastHash: h, mode });
    } else {
      if (!force && slot.lastHash === h) return;
      await bot.editMessageText(text, { ...kb, chat_id: chatId, message_id: slot.msgId }).catch(()=>{});
      slot.lastHash = h;
    }
  }

  bot.onText(CMD, async (msg) => {
    const chatId = msg.chat.id;
    const prev = SLOTS.get(chatId);
    if (prev?.timer) clearInterval(prev.timer);

    const mode = loadPolicySync()?.execution?.mode || 'demo';
    SLOTS.set(chatId, { msgId: null, auto: true, timer: null, lastHash: '', mode });

    await render(chatId, true);

    const t = setInterval(() => {
      const s = SLOTS.get(chatId);
      if (!s?.auto) return;
      render(chatId).catch(()=>{});
    }, 5000);
    SLOTS.get(chatId).timer = t;
  });

  bot.on('callback_query', async (q) => {
    const chatId = q.message?.chat?.id;
    const data = q.data || '';
    if (!chatId || !data || !data.startsWith('w|')) return;

    const parts = data.split('|'); // w|action|...
    const action = parts[1];

    if (action === 'refresh') {
      await render(chatId, true);
      return bot.answerCallbackQuery(q.id, { text: 'Refrescado' }).catch(()=>{});
    }
    if (action === 'toggle') {
      const slot = SLOTS.get(chatId);
      if (!slot) return bot.answerCallbackQuery(q.id).catch(()=>{});
      slot.auto = !slot.auto;
      await render(chatId, true);
      return bot.answerCallbackQuery(q.id, { text: slot.auto ? 'Auto-Refresh ON' : 'Auto-Refresh OFF' }).catch(()=>{});
    }
    if (action === 'sell') {
      const [, , mode, mint, pctStr] = parts;
      const pct = Number(pctStr);

      // preferimos el trading pasado por deps (tu wiring actual)
      const TT = pickTrading(deps);
      let sellFn = null;
      if (typeof TT.sellPercent === 'function') sellFn = TT.sellPercent;
      if (!sellFn && typeof TT.sellByPercent === 'function') sellFn = TT.sellByPercent;

      if (!sellFn) {
        await bot.answerCallbackQuery(q.id, { text: 'Venta rÃ¡pida aÃºn no estÃ¡ conectada a trading.js', show_alert: true }).catch(()=>{});
        return;
      }
      try {
        await bot.answerCallbackQuery(q.id, { text: `Vender ${pct}%â€¦` }).catch(()=>{});
        await sellFn({ mint, percent: pct, mode, source: 'wallet' });
        await render(chatId, true);
      } catch (e) {
        await bot.answerCallbackQuery(q.id, { text: `Error: ${e?.message || e}`, show_alert: true }).catch(()=>{});
      }
      return;
    }
  });

  process.on('exit', () => {
    for (const s of SLOTS.values()) if (s?.timer) clearInterval(s.timer);
  });
}
