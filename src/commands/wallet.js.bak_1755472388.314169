// src/commands/wallet.js — vista única /wallet con selección, PnL correcto y refresco

// === PnL helpers (seguros) ===
function __formatPnl(u, p) {
  u = Number(u) || 0;
  p = Number(p) || 0;
  const sign = u >= 0 ? '+' : '-';
  const absU = Math.abs(u).toFixed(2);
  const pctS = (p >= 0 ? '+' : '') + p.toFixed(1) + '%';
  return `${sign}$${absU} (${pctS})`;
}

function __deriveHeaderPnlFrom(list, prices) {
  try {
    if (!Array.isArray(list) || list.length === 0) return '$0.00 (+0.0%)';
    const base = list[0];
    // Si ya viene pnl de la API, úsalo
    if (typeof base.pnlUsd === 'number' && typeof base.pnlPct === 'number') {
      return __formatPnl(base.pnlUsd, base.pnlPct);
    }
    // Fallback: calcula con entry/now/invested
    const entry = Number(base.entryPriceUsd || 0);
    const inv   = Number(base.investedUsd   || 0);
    const now   = Number((prices && prices.get && prices.get(base.mint)) || 0);
    if (entry > 0 && inv > 0 && now > 0) {
      const pct = (now / entry - 1) * 100;
      const usd = (pct / 100) * inv;
      return __formatPnl(usd, pct);
    }
  } catch {}
  return '$0.00 (+0.0%)';
}

// === imports (ESM) ===
import crypto from 'node:crypto';
import { loadState, saveState } from '../services/state_compat.js';
import { getPriceUSD }          from '../services/prices.js';
import { loadPolicySync }       from '../policy.js';

// === config & state ===
const REFRESH_MS   = Number(process.env.WALLET_REFRESH_MS || 5000);
const RESIDUAL_USD = Number(process.env.WALLET_RESIDUAL_USD || 1);
const MAX_POS      = 10;
const API_BASE     = process.env.API_BASE || 'http://127.0.0.1:3000';

const SLOTS = new Map(); // chatId -> { msgId, auto, timer, lastHash, selectedId, busy, busyAt }

const EMO = {
  header:  '📱',
  real:    '💳',
  demo:    '🧪',
  token:   '🪙',
  entry:   '📥',
  price:   '📤',
  invest:  '💵',
  pnl:     '📈',
  linkDs:  '📊',
  linkSc:  '📎',
  linkJp:  '🌀',
  linkRd:  '🌊',
  selOn:   '✅',
  selOff:  '🎯',
  refresh: '🔄',
  autoOn:  '🟢',
  autoOff: '⚪',
  sell:    '💯',
};

// === helpers varios ===
function fmtUsd(n){ return Number(n||0).toLocaleString('en-US',{style:'currency',currency:'USD',minimumFractionDigits:2,maximumFractionDigits:2}); }
function safeSymbol(s){ return String(s||'TOKEN').slice(0,12).toUpperCase(); }
function round2(x){ return Math.round(Number(x||0)*100)/100; }

function dsLink(mint){ return `https://dexscreener.com/solana/${mint}`; }
function scLink(mint){ return `https://solscan.io/token/${mint}`; }
function jpLink(mint){ return `https://jup.ag/swap/SOL-${mint}`; }
function rdLink(mint){ return `https://raydium.io/swap/?inputCurrency=sol&outputCurrency=${mint}`; }

function pnlFor(pos, priceNow) {
  // Texto por compatibilidad
  const entry = Number(pos.entryPriceUsd||0);
  const inv   = Number(pos.investedUsd||0);
  const now   = Number(priceNow||0);
  if (entry<=0 || inv<=0 || now<=0) return { pct:'0.0%', usd:fmtUsd(0) };
  const pct = (now/entry - 1) * 100;
  const usd = (pct/100) * inv;
  return { pct:`${pct.toFixed(1)}%`, usd:fmtUsd(usd) };
}

function pnlNums(pos, priceNow) {
  const entry = Number(pos.entryPriceUsd||0);
  const inv   = Number(pos.investedUsd||0);
  const now   = Number(priceNow||0);
  if (entry<=0 || inv<=0 || now<=0) return { pct:0, usd:0 };
  const pct = (now/entry - 1) * 100;
  const usd = (pct/100) * inv;
  return { pct, usd };
}

function hashPayload(...parts){
  const h=crypto.createHash('sha1');
  for (const p of parts) h.update(String(typeof p==='string'?p:JSON.stringify(p)));
  return h.digest('hex');
}

function getActiveMode(){
  try { return (loadPolicySync()?.execution?.mode) || 'demo'; }
  catch { return 'demo'; }
}

async function fetchPrices(mints){
  const out = new Map();
  for (const mint of mints){
    try { out.set(mint, await getPriceUSD(mint)); } catch { out.set(mint, 0); }
  }
  return out;
}

function buildKeyboard(visible, slot, prices){
  // 1) fila por token seleccionable
  const kb = visible.map(p=>{
    const price = prices.get(p.mint) || 0;
    const sel   = (slot.selectedId === p.id);
    const pn    = (typeof p.pnlUsd==='number' && typeof p.pnlPct==='number')
      ? __formatPnl(p.pnlUsd, p.pnlPct)
      : __formatPnl(pnlNums(p, price).usd, pnlNums(p, price).pct);
    const label = `${sel?EMO.selOn:EMO.selOff} ${safeSymbol(p.symbol)} • ${pn}`;
    return [{ text: label, callback_data: `select:${p.id}` }];
  });

  // 2) ventas parciales (si hay seleccionada)
  if (slot.selectedId){
    const id = slot.selectedId;
    kb.push([
      { text: '25%', callback_data: `sell:${id}:25` },
      { text: '50%', callback_data: `sell:${id}:50` },
      { text: '75%', callback_data: `sell:${id}:75` },
      { text: '💯',  callback_data: `sell:${id}:100` },
    ]);
  }

  // 3) controles
  kb.push([
    { text: `${EMO.refresh} Refrescar`, callback_data: 'refresh' },
    { text: slot.auto? `${EMO.autoOn} Auto` : `${EMO.autoOff} Auto`, callback_data: 'toggle:auto' },
  ]);

  return { inline_keyboard: kb };
}

// === texto principal ===
function renderText(activeMode, positions, prices, st){
  const lines = [];

  // Header simple
  const demoCount = positions.filter(p=>p.mode==='demo').length;
  const realCount = positions.filter(p=>p.mode==='real').length;
  const total     = positions.length;
  lines.push(`**${EMO.header} Posiciones abiertas**`);
  lines.push(`• DEMO: ${demoCount}`);
  lines.push(`• REAL: ${realCount}`);
  lines.push(`• Total: ${total}`);

  // Wallet segun modo
  if (activeMode==='real'){
    const addr = String(st?.phantom?.address||'-');
    const inv  = fmtUsd(positions.filter(p=>p.mode==='real').reduce((a,p)=>a+Number(p.investedUsd||0),0));
    const free = fmtUsd(Number(st?.phantom?.free||0));
    const tot  = fmtUsd(Number(st?.phantom?.free||0) + positions.filter(p=>p.mode==='real').reduce((a,p)=>a+Number(p.investedUsd||0),0));
    lines.push(`\n**${EMO.real} Billetera Phantom (REAL)**`);
    lines.push(`• Address: ${addr}`);
    lines.push(`• Invertido: ${inv}`);
    lines.push(`• Libre para sniper: ${free}`);
    lines.push(`• Total disponible: ${tot}`);
  } else {
    // normaliza cash demo si falta
    const invDemoNum = positions.filter(p=>p.mode==='demo').reduce((a,p)=>a+Number(p.investedUsd||0),0);
    let demoCashNum  = Number(st?.demo?.cash || 0);
    if (!Number.isFinite(demoCashNum) || demoCashNum < 0 || demoCashNum > 1_000_000) {
      demoCashNum = Math.max(0, 10_000 - invDemoNum);
    }
    const inv  = fmtUsd(invDemoNum);
    const free = fmtUsd(demoCashNum);
    const tot  = fmtUsd(demoCashNum + invDemoNum);
    lines.push(`\n**${EMO.demo} Billetera DEMO**`);
    lines.push(`• Invertido: ${inv}`);
    lines.push(`• Libre para sniper: ${free}`);
    lines.push(`• Total disponible: ${tot}`);
  }

  lines.push(`\n*Modo activo: ${activeMode.toUpperCase()}*`);

  // Listado de posiciones del modo activo
  const list = positions.filter(p=>p.mode===activeMode).slice(0, MAX_POS);

  // PnL global de header derivado de la primera del modo activo (usa API si viene)
  const headerText = __deriveHeaderPnlFrom(list, prices);

  for (const pos of list){
    const price = prices.get(pos.mint) || 0;
    lines.push(`\n${EMO.token} $${safeSymbol(pos.symbol)} **(${pos.mode.toUpperCase()})**`);
    lines.push(`${EMO.entry} Entrada: ${round2(Number(pos.entryPriceUsd||0))}`);
    lines.push(`${EMO.price} Actual: ${round2(price)}`);
    lines.push(`${EMO.invest} Invertido: ${fmtUsd(pos.investedUsd||0)}`);
    lines.push(`${EMO.pnl} PnL: ${headerText}`);
    lines.push(`${EMO.linkDs} [DexScreener](${dsLink(pos.mint)})  |  ${EMO.linkSc} [Solscan](${scLink(pos.mint)})  |  ${EMO.linkJp} [Jupiter](${jpLink(pos.mint)})  |  ${EMO.linkRd} [Raydium](${rdLink(pos.mint)})`);
  }

  // Header de la seleccionada al tope
  const slot = SLOTS.get(global.__HX_LAST_CHATID__) || {};
  const posSel = list.find(p=>p.id===slot.selectedId) || list[0];
  if (posSel){
    lines.unshift(`**${EMO.token} ${safeSymbol(posSel.symbol)} — PnL: ${headerText}**`);
  }

  return lines.join('\n');
}

// === ventas parciales contra API ===
async function apiSell(posId, pct){
  const r = await fetch(`${API_BASE}/api/sell`, {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify({ posId, pct: Number(pct) })
  }).then(r=>r.json()).catch(()=>({ ok:false }));
  return r?.ok ? r : { ok:false };
}

// === render principal del comando ===
async function render(bot, chatId, deps, force=false){
  const slot = SLOTS.get(chatId) || { auto:true };
  SLOTS.set(chatId, slot);
  global.__HX_LAST_CHATID__ = chatId;

  // breaker anti-deadlock
  if (slot.busy){
    if (!slot.busyAt || (Date.now()-slot.busyAt)>8000) { slot.busy=false; }
    else { return; }
  }
  slot.busy   = true;
  slot.busyAt = Date.now();

  try {
    const st = loadState();
    st.positions = st.positions || {};
    const demoArr = Array.isArray(st.positions.demo) ? st.positions.demo.filter(p=>p.isOpen!==false && Number(p.investedUsd||0)>0) : [];
    const realArr = Array.isArray(st.positions.real) ? st.positions.real.filter(p=>p.isOpen!==false && Number(p.investedUsd||0)>0) : [];

    // ordenar por fecha desc
    demoArr.sort((a,b)=>Number(b.openedAt||0)-Number(a.openedAt||0));
    realArr.sort((a,b)=>Number(b.openedAt||0)-Number(a.openedAt||0));

    // init cash demo si falta
    st.demo = st.demo || {};
    if (typeof st.demo.cash !== 'number') {
      const sumInv = demoArr.reduce((a,p)=>a+Number(p.investedUsd||0),0);
      st.demo.cash = Math.max(0, 10_000 - sumInv);
      saveState(st);
    }

    const activeMode = getActiveMode(); // 'demo' o 'real'
    const positions  = [...demoArr, ...realArr];

    // Precios para los mints usados
    const mints  = Array.from(new Set(positions.map(p=>p.mint))).slice(0, 50);
    const prices = await fetchPrices(mints);

    // Selección default por modo activo
    const visible = positions.filter(p=>p.mode===activeMode);
    if (!slot.selectedId && visible.length>0) slot.selectedId = visible[0].id;

    // Texto + keyboard
    const text = renderText(activeMode, positions, prices, st);
    const kb   = buildKeyboard(visible, slot, prices);
    const h    = hashPayload(text, kb, slot.selectedId, slot.auto);

    if (!slot.msgId){
      const sent = await bot.sendMessage(chatId, text, {
        reply_markup: kb,
        parse_mode: 'Markdown',
        disable_web_page_preview: true
      });
      slot.msgId   = sent.message_id;
      slot.lastHash= h;
    } else if (force || h !== slot.lastHash){
      await bot.editMessageText(text, {
        chat_id: chatId,
        message_id: slot.msgId,
        reply_markup: kb,
        parse_mode: 'Markdown',
        disable_web_page_preview: true
      }).catch((e)=>{
        const m=String(e?.message||e||'');
        if (!/message is not modified/i.test(m)) console.error('editMessageText:', m);
      });
      slot.lastHash = h;
    }

  } catch (e) {
    console.error('render /wallet:', e?.message||e);
  } finally {
    SLOTS.set(chatId, { ...SLOTS.get(chatId), busy:false, busyAt:0 })
  }
}

// === registro de comandos/callbacks ===
export default function setupWalletCommand(bot){
  // /wallet
  bot.onText(/^\/wallet(?:\s+.*)?$/i, async (msg) => {
    const chatId = msg.chat.id;
    await render(bot, chatId, {}, true);
    // auto-refresh
    const slot = SLOTS.get(chatId);
    if (slot?.timer) clearInterval(slot.timer);
    if (slot?.auto){
      slot.timer = setInterval(()=>render(bot, chatId, {}, false), REFRESH_MS);
      SLOTS.set(chatId, slot);
    }
  });

  // callback buttons
  bot.on('callback_query', async (q) => {
    try {
      if (!q?.data) return;
      const chatId = q.message?.chat?.id;
      if (!chatId) return;
      // acciones
      if (q.data.startsWith('select:')){
        const id = q.data.split(':')[1];
        const slot = SLOTS.get(chatId) || {};
        slot.selectedId = id;
        SLOTS.set(chatId, slot);
        await render(bot, chatId, {}, true);
      }
      else if (q.data === 'refresh'){
        await render(bot, chatId, {}, true);
      }
      else if (q.data === 'toggle:auto'){
        const slot = SLOTS.get(chatId) || { auto:true };
        slot.auto = !slot.auto;
        if (!slot.auto && slot.timer){ clearInterval(slot.timer); slot.timer=null; }
        if (slot.auto && !slot.timer){
          slot.timer = setInterval(()=>render(bot, chatId, {}, false), REFRESH_MS);
        }
        SLOTS.set(chatId, slot);
        await render(bot, chatId, {}, true);
      }
      else if (q.data.startsWith('sell:')){
        const [, id, pctStr] = q.data.split(':');
        const pct = Number(pctStr||0);
        if (id && pct>0){
          const r = await apiSell(id, pct);
          if (!r?.ok) {
            await bot.answerCallbackQuery(q.id, { text: 'Venta falló', show_alert:false }).catch(()=>{});
          } else {
            await bot.answerCallbackQuery(q.id, { text: `Vendido ${pct}%`, show_alert:false }).catch(()=>{});
          }
          await render(bot, chatId, {}, true);
        }
      }
    } catch (e) {
      console.error('wallet cb:', e?.message||e);
    }
  });
}

/* 
// Si tu loader NO espera una función por defecto, y en cambio
// espera un objeto { name, setup }, podés usar esta variante:

export const name = 'wallet';
export function setup(bot){ return setupWalletCommand(bot); }

*/
