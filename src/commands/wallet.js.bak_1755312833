// src/commands/wallet.js — SINGLE MESSAGE (summary + TODAS las posiciones)
// - Un solo mensaje que se EDITA cada 5s (no spam).
// - Botones 25/50/75/100% para cada posición (todas en la misma inline keyboard).
// - Links DexScreener / Solscan / Jupiter / Raydium por token.
// - DEMO: vende parcial en archivo state.json; REAL: llama trading.sellPercent si está implementado.

import * as fs from 'fs';
import * as path from 'path';
import * as prices from '../services/prices.js';
import * as trading from '../services/trading.js'; // hook REAL (si lo tenés)
import { loadPolicySync } from '../policy.js';

const REFRESH_MS = Number(process.env.WALLET_REFRESH_MS || '5000'); // 5s
const MAX_POS = 10;

// Por chat guardamos: { msgId, auto, lastAt, refreshing }
const SLOTS = new Map();

/* ────────────── helpers ────────────── */
function loadState() {
  try {
    const p = path.join(process.cwd(), 'data', 'state.json');
    return JSON.parse(fs.readFileSync(p, 'utf8'));
  } catch { return {}; }
}
function saveState(st) {
  const p = path.join(process.cwd(), 'data', 'state.json');
  fs.mkdirSync(path.dirname(p), { recursive: true });
  fs.writeFileSync(p, JSON.stringify(st, null, 2));
}
function esc(s=''){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
function fmtUsd(n){ if(n==null||Number.isNaN(n))return '—';
  return new Intl.NumberFormat('en-US',{style:'currency',currency:'USD',maximumFractionDigits:2}).format(Number(n));
}
function short(s,n=6){ if(!s)return '—'; return s.length>2*n ? s.slice(0,n)+'…'+s.slice(-n) : s; }
function activeMode(){ return (loadPolicySync()?.execution?.mode)||'demo'; }
function pickOpen(arr){ return (Array.isArray(arr)?arr:[]).filter(p=>p?.isOpen!==false && p?.status!=='closed'); }
function calcPnl(pos, lastPriceUsd){
  if (!pos?.entryPriceUsd || !lastPriceUsd || !pos?.investedUsd) {
    return { pct: '—', usd: '—' };
  }
  const tokensHeld = Number(pos.investedUsd) / Number(pos.entryPriceUsd);
  const mktUsd     = tokensHeld * Number(lastPriceUsd);
  const pnlUsd     = mktUsd - Number(pos.investedUsd);
  const pct        = (Number(pos.investedUsd) > 0)
    ? (pnlUsd / Number(pos.investedUsd)) * 100
    : 0;
  return { pct: (pct.toFixed(1) + '%'), usd: fmtUsd(pnlUsd) };
}
function linkDex(mint){ return `https://dexscreener.com/solana/${mint}`; }
function linkSolscan(mint){ return `https://solscan.io/token/${mint}`; }
// Enlaces “universales” de swap (no dependen de tu CEX/LP real, solo para abrir rápido el swap)
function linkJupiter(mint){ return `https://jup.ag/swap/SOL-${mint}`; }
function linkRaydium(mint){ return `https://raydium.io/swap/?inputCurrency=sol&outputCurrency=${mint}`; }

async function enrichWithPrice(items){
  const out=[]; for(const pos of items){
    let lastPriceUsd=null;
    try{ const p=await prices.getPriceUSD(pos.mint); lastPriceUsd=Number(p?.price||0)||null; }catch{}
    out.push({...pos,lastPriceUsd});
  } return out;
}

/* ────────────── DEMO sells ────────────── */
function demoSellPercent(state, posId, pct, lastPriceUsd) {
  const pools=[state.positions?.demo||[], state.positions?.real||[]];
  let pos, arr, idx=-1;
  for(const a of pools){ const k=a.findIndex(x=>x?.id===posId); if(k>=0){pos=a[k];arr=a;idx=k;break;} }
  if(!pos) throw new Error('Posición no encontrada');

  pct=Math.min(100,Math.max(1,Number(pct||0)));
  const fraction=pct/100;
  const entry=Number(pos.entryPriceUsd||0), inv=Number(pos.investedUsd||0);
  if(entry<=0||inv<=0) throw new Error('Entrada/invertido inválido');

  const tokensHeld=inv/entry;
  const tokensToSell=tokensHeld*fraction;
  const proceedsUsd=tokensToSell*Number(lastPriceUsd||entry);
  const costUsd=inv*fraction;
  const realizedPnl=proceedsUsd-costUsd;

  pos.realizedUsd = Number(pos.realizedUsd||0)+proceedsUsd;
  pos.realizedPnlUsd = Number(pos.realizedPnlUsd||0)+realizedPnl;
  pos.realizedAt = Date.now();
  pos.fills = Array.isArray(pos.fills)?pos.fills:[];
  pos.fills.push({type:'sell',pct,proceedsUsd,realizedPnl,at:pos.realizedAt,priceUsd:lastPriceUsd});

  pos.investedUsd = inv - costUsd;
  if(pos.investedUsd<=0.000001){ pos.investedUsd=0; pos.isOpen=false; pos.status='closed'; pos.closedAt=Date.now(); }
  saveState(state);
  return { proceedsUsd, realizedPnl };
}

/* ────────────── render de TEXTO (todo en 1 mensaje) ────────────── */
function renderOneMessageText(st, mode, list){
  const demoOpen=pickOpen(st.positions?.demo).length;
  const realOpen=pickOpen(st.positions?.real).length;
  const lines=[];
  lines.push('<b>📱 Posiciones abiertas</b>');
  lines.push('');
  lines.push(`• DEMO: ${demoOpen}`);
  lines.push(`• REAL: ${realOpen}`);
  lines.push(`• Total: ${demoOpen+realOpen}`);
  lines.push('');
  lines.push('<b>💳 Billetera Phantom (REAL)</b>');
  lines.push(`• Address: <code>${esc(short(process.env.PHANTOM_ADDRESS||''))}</code>`);
  lines.push(`• Invertido: —`);
  lines.push(`• Libre para sniper: —`);
  lines.push(`• Total disponible: —`);
  lines.push('');
  lines.push('<b>🧪 Billetera DEMO</b>');
  lines.push(`• Invertido: —`);
  lines.push(`• Libre para sniper: ${fmtUsd(Number(process.env.DEMO_CASH_USD||'1000'))}`);
  lines.push(`• Total disponible: —`);
  lines.push('');
  lines.push(`<i>Modo activo: ${mode.toUpperCase()}</i>`);
  lines.push('');

  for (const pos of list) {
    const pnl=calcPnl(pos,pos.lastPriceUsd);
    lines.push(
      [
        `🪙 <b>$${esc(pos.symbol||'TOKEN')}</b> <i>(${mode.toUpperCase()})</i>`,
        `📥 Entrada: ${pos.entryPriceUsd ?? '—'}`,
        `📤 Actual: ${pos.lastPriceUsd ?? '—'}`,
        `💵 Invertido: ${fmtUsd(pos.investedUsd)}`,
        `📈 PnL: ${esc(pnl.pct)} (${esc(pnl.usd)})`,
        `<a href="${esc(linkDex(pos.mint))}">📊 DexScreener</a>  |  <a href="${esc(linkSolscan(pos.mint))}">📎 Solscan</a>  |  <a href="${esc(linkJupiter(pos.mint))}">🌀 Jupiter</a>  |  <a href="${esc(linkRaydium(pos.mint))}">🌊 Raydium</a>`
      ].join('\n')
    );
    lines.push(''); // separador entre tokens
  }
  return lines.join('\n');
}

/* ────────────── render de TECLAS (todas en 1 keyboard) ────────────── */
function buildOneKeyboard(list, auto){
  const kb = [];

  // Por cada posición, fila de 4 botones
  for (const pos of list) {
    kb.push([
      { text:`🔁 25%`, callback_data:`w:sell:${pos.id}:25` },
      { text:`🔁 50%`, callback_data:`w:sell:${pos.id}:50` },
      { text:`🔁 75%`, callback_data:`w:sell:${pos.id}:75` },
      { text:`💯 Vender`, callback_data:`w:sell:${pos.id}:100` },
    ]);
  }

  // Fila de controles al final
  kb.push([
    { text:'🔄 Refrescar', callback_data:'w:refresh' },
    { text: auto? '🟢 Auto: ON':'⚫ Auto: OFF', callback_data:'w:auto' }
  ]);

  return { inline_keyboard: kb };
}

/* ────────────── refresh (edita un solo mensaje) ────────────── */
async function refreshSingleMessage(bot, chatId){
  const key = String(chatId);
  const slot = SLOTS.get(key) || { auto:true, msgId:null, refreshing:false, lastAt:0 };
  if (slot.refreshing) return; // throttle: evita superponer
  slot.refreshing = true;
  SLOTS.set(key, slot);

  try {
    const mode = activeMode();
    const st = loadState();
    const raw = mode==='real' ? pickOpen(st.positions?.real) : pickOpen(st.positions?.demo);
    const list = (raw||[]).slice(0,MAX_POS);
    const enriched = await enrichWithPrice(list);

    const text = renderOneMessageText(st, mode, enriched);
    const kb   = buildOneKeyboard(enriched, slot.auto);

    if (slot.msgId) {
      try {
        await bot.editMessageText(text, {
          chat_id: chatId, message_id: slot.msgId,
          parse_mode:'HTML', disable_web_page_preview:true, reply_markup: kb
        });
      } catch (e) {
        const msg = String(e?.message||e);
        // "message is not modified" => ignorar; "message to edit not found" => re-enviar
        if (!/message is not modified/i.test(msg)) {
          const sent = await bot.sendMessage(chatId, text, {
            parse_mode:'HTML', disable_web_page_preview:true, reply_markup: kb
          });
          slot.msgId = sent.message_id;
        }
      }
    } else {
      const sent = await bot.sendMessage(chatId, text, {
        parse_mode:'HTML', disable_web_page_preview:true, reply_markup: kb
      });
      slot.msgId = sent.message_id;
    }

    slot.lastAt = Date.now();
    SLOTS.set(key, slot);
  } finally {
    // pequeño delay para no encimar ediciones
    setTimeout(()=>{ const s=SLOTS.get(key); if(s) s.refreshing=false; }, 250);
  }
}

/* ────────────── loop ────────────── */
let LOOP=null;
function ensureLoop(bot){
  if (LOOP) return;
  LOOP = setInterval(async ()=>{
    for (const [cid, slot] of SLOTS) {
      if (!slot?.auto) continue;
      if (Date.now() - (slot.lastAt||0) < REFRESH_MS - 100) continue;
      try { await refreshSingleMessage(bot, cid); } catch {}
    }
  }, REFRESH_MS);
}

/* ────────────── registro comandos/callbacks ────────────── */
export default function registerWallet(bot){

  bot.onText(/^\/wallet$/, async (msg)=>{
    const chatId = msg.chat.id;
    if (!SLOTS.has(String(chatId))) SLOTS.set(String(chatId), { auto:true, msgId:null, refreshing:false, lastAt:0 });
    await refreshSingleMessage(bot, chatId);
    ensureLoop(bot);
  });

  bot.on('callback_query', async (q)=>{
    try {
      const data = String(q.data||'');
      const chatId = q.message?.chat?.id;
      if (!chatId) return;

      const slot = SLOTS.get(String(chatId)) || { auto:true, msgId:null, refreshing:false, lastAt:0 };
      SLOTS.set(String(chatId), slot);

      if (data === 'w:auto') {
        slot.auto = !slot.auto;
        await refreshSingleMessage(bot, chatId);
        try { await bot.answerCallbackQuery(q.id, { text:`Auto: ${slot.auto?'ON':'OFF'}` }); } catch {}
        return;
      }
      if (data === 'w:refresh') {
        await refreshSingleMessage(bot, chatId);
        try { await bot.answerCallbackQuery(q.id); } catch {}
        return;
      }

      // w:sell:<id>:<pct>
      const m = data.match(/^w:sell:([^:]+):([0-9]+)$/);
      if (m) {
        const posId = m[1];
        const pct   = Number(m[2]);

        const st = loadState();
        const poolDemo = st.positions?.demo || [];
        const poolReal = st.positions?.real || [];
        let pos = poolDemo.find(x=>x.id===posId);
        let arrName = 'demo';
        if (!pos) { pos = poolReal.find(x=>x.id===posId); arrName = 'real'; }
        if (!pos) throw new Error('Posición no encontrada');

        // Precio (otra vez por seguridad)
        let last = pos.lastPriceUsd;
        if (!last) { try { const r=await prices.getPriceUSD(pos.mint); last=Number(r?.price||0)||null; } catch{} }
        if (!last) throw new Error('No pude obtener precio');

        if (arrName==='demo') {
          demoSellPercent(st, posId, pct, last);
          try { await bot.answerCallbackQuery(q.id, { text:`DEMO ${pct}% ✅` }); } catch {}
        } else {
          if (typeof trading.sellPercent==='function') {
            await trading.sellPercent({ id: posId, mint: pos.mint, symbol: pos.symbol }, pct, { priceUsd: last });
            try { await bot.answerCallbackQuery(q.id, { text:`REAL ${pct}% enviado ✅` }); } catch {}
          } else {
            try { await bot.answerCallbackQuery(q.id, { text:`REAL aún no implementado` }); } catch {}
          }
        }
        await refreshSingleMessage(bot, chatId);
        return;
      }
    } catch (e) {
      try { await bot.answerCallbackQuery(q.id, { text: '⚠️ '+(e?.message||'Error') }); } catch {}
    }
  });
}
