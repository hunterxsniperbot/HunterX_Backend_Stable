// src/commands/wallet.js ‚Äî posiciones abiertas (vivo) + vender
import { buildMetrics } from '../services/positions.js';
// Aseguramos tambi√©n quoteToUSDC para cotizar si hace falta
import { sellToUSDC, quoteToUSDC } from '../services/swap.js';

  // --- callbacks para botones de venta (wallet:sell:xx:MODE:<symbol>[:<mint>[:<qty>]])
  bot.on('callback_query', async (q) => {
    try {
      const data = q?.data || '';
      if (!/^wallet:(sell|quote):/i.test(data)) return;

      const uid    = String(q.from.id);
      const chatId = q.message?.chat?.id || q.message?.chat_id;
      const mid    = q.message?.message_id;

      // Formatos soportados:
      // wallet:sell:25:DEMO:SOL
      // wallet:sell:50:REAL:SOL:So1111...:123.45
      // wallet:quote:100:DEMO:SOL
      const parts = data.split(':'); // [wallet, action, pct, MODE, symbol, mint?, qty?]
      const action  = (parts[1] || 'sell').toLowerCase();
      const percent = Number(parts[2] || '100');
      const mode    = (parts[3] || 'DEMO').toUpperCase();
      const symbol  = decodeURIComponent((parts[4] || '').trim());
      const mint    = parts[5] && parts[5].length > 0 ? parts[5].trim() : undefined;
      let qty       = parts[6] ? Number(parts[6]) : NaN;

      const real = (mode === 'REAL') && !!(bot.realMode?.[uid]);

      // Busca qty si viene vac√≠o
      if (!Number.isFinite(qty) || qty <= 0) {
        try {
          const posMod = await import('../services/positions.js');
          const get = posMod.getOpenPositions || posMod.readOpenPositions || posMod.listOpenPositions;
          if (typeof get === 'function') {
            const rows = await get({ uid, mode });
            const hit  = Array.isArray(rows)
              ? rows.find(r =>
                  (r.symbol && r.symbol.toUpperCase() === symbol.toUpperCase()) ||
                  (mint && r.mint && r.mint === mint)
                )
              : null;
            if (hit && Number.isFinite(Number(hit.qty))) {
              qty = Number(hit.qty);
            }
          }
        } catch (_) {}
      }

      await (q.id ? bot.answerCallbackQuery(q.id).catch(()=>{}) : Promise.resolve());

      if (action === 'quote') {
        if (!Number.isFinite(qty) || qty <= 0) {
          return bot.sendMessage(chatId, '‚ö†Ô∏è No tengo cantidad para cotizar. Reabre /wallet y toca el bot√≥n desde la tarjeta de la posici√≥n.', { parse_mode: 'HTML' });
        }
        const qt = await quoteToUSDC({ symbol, mint, qty, percent });
        if (!qt?.ok) {
          return bot.sendMessage(chatId, '‚ö†Ô∏è No se pudo obtener cotizaci√≥n ahora mismo.', { parse_mode:'HTML' });
        }
        const html = [
          `<b>üìê Cotizaci√≥n</b>`,
          `‚Ä¢ Token: <b>${symbol || (mint || '').slice(0,6)+'‚Ä¶'}</b>`,
          `‚Ä¢ Cantidad: <b>${qty}</b>`,
          `‚Ä¢ Vender: <b>${percent}%</b>`,
          `‚Ä¢ Precio: <b>$${qt.priceUsd.toFixed(6)}</b>`,
          `‚Ä¢ Recibir ‚âà <b>$${qt.toUSDC.toFixed(2)} USDC</b>`,
        ].join('\n');
        return bot.sendMessage(chatId, html, { parse_mode:'HTML' });
      }

      // SELL (DEMO por ahora; REAL queda en modo simulado seguro dentro de sellToUSDC)
      if (!Number.isFinite(qty) || qty <= 0) {
        return bot.sendMessage(chatId, '‚ö†Ô∏è No tengo cantidad para vender. Reabre /wallet y toca el bot√≥n desde la tarjeta de la posici√≥n.', { parse_mode: 'HTML' });
      }

      const res = await sellToUSDC({ bot, uid, symbol, mint, qty, percent, real });
      if (!res?.ok) {
        return bot.sendMessage(chatId, '‚ö†Ô∏è No se pudo ejecutar la orden (simulada).', { parse_mode:'HTML' });
      }

      const sim = res.simulated ? ' (simulado)' : '';
      const html = [
        `<b>‚úÖ Venta${sim} ejecutada</b>`,
        `‚Ä¢ Modo: <b>${real ? 'REAL' : 'DEMO'}</b>`,
        `‚Ä¢ Token: <b>${symbol || (mint || '').slice(0,6)+'‚Ä¶'}</b>`,
        `‚Ä¢ Vendido: <b>${percent}%</b> de <b>${qty}</b>`,
        res.quote?.priceUsd ? `‚Ä¢ Precio usado: <b>$${Number(res.quote.priceUsd).toFixed(6)}</b>` : null,
        res.receivedUSDC ? `‚Ä¢ Recibido: <b>$${Number(res.receivedUSDC).toFixed(2)} USDC</b>` : null,
        res.txid ? `‚Ä¢ TX: <code>${res.txid}</code>` : null,
      ].filter(Boolean).join('\n');

      await bot.sendMessage(chatId, html, { parse_mode:'HTML' });

      // TIP: ac√° podr√≠amos refrescar /wallet autom√°ticamente invocando su renderer, si quer√©s.
    } catch (e) {
      try { if (q?.id) await bot.answerCallbackQuery(q.id, { text: 'Error' }); } catch {}
      console.error('wallet callback err', e?.message || e);
    }
  });
import * as trading from '../services/trading.js'; // asume logTrade/logEvent

const sleep = (ms)=> new Promise(r=>setTimeout(r,ms));
function jitter(ms){ return Math.max(1000, Math.floor(ms * (0.9 + Math.random()*0.2))); }
function nextDelay({prevMs, changed, errorCount, baseMs}){
  if (errorCount>0) return Math.min((prevMs||baseMs)*1.5, 30000);
  return changed ? baseMs : Math.min((prevMs||baseMs)+2000, 12000);
}
function fmtUSD(n){ return '$' + (Number(n||0)).toLocaleString('en-US',{minimumFractionDigits:2,maximumFractionDigits:2}); }
function bpsOf(pct){ return Math.round(Number(pct)*100); }

function renderPosition(p){
  const arrow = p.pnlPct>=0 ? 'üìà' : 'üìâ';
  const name  = p.sym.startsWith('$') ? p.sym : ('$'+p.sym);
  const ds = [
    `ü™ô <b>${name}</b>`,
    `üì• Entrada: ${p.entry.toFixed(6)} USD`,
    `üì§ Actual: ${p.now.toFixed(6)} USD`,
    `üì¶ Qty: ${p.qty}`,
    `üíµ Invertido: ${fmtUSD(p.invested)}`,
    `${arrow} PnL: <b>${p.pnlPct.toFixed(2)}%</b> (${fmtUSD(p.pnlAbs)})`
  ];
  return ds.join('\n');
}

function buildKeyboard(mode, which, idx){
  // which: 'd' demo, 'r' real ‚Äî idx: √≠ndice visual en la lista mostrada
  const base = `wallet:sell:${which}:${idx}`;
  return {
    inline_keyboard: [
      [
        { text:'üîÅ 25%', callback_data: `${base}:25` },
        { text:'üîÅ 50%', callback_data: `${base}:50` },
        { text:'üîÅ 75%', callback_data: `${base}:75` },
        { text:'üíØ Vender', callback_data: `${base}:100` },
      ]
    ]
  };
}

async function snapshot(bot, uid, max=10){
  const storeDemo = bot._store_demo?.[uid] || [];
  const storeReal = bot._store_real?.[uid] || [];
  const m = await buildMetrics({ storeDemo, storeReal, max });

  const topD = m.demo.list;
  const topR = m.real.list;

  const lines = [
    '<b>üì± Posiciones abiertas</b>',
    '',
    `‚Ä¢ DEMO: <b>${m.demo.count}</b>`,
    `‚Ä¢ REAL: <b>${m.real.count}</b>`,
    `‚Ä¢ Total: <b>${m.demo.count + m.real.count}</b>`,
    '',
    '<b>üí≥ Billetera Phantom (REAL)</b>',
    '<i>(balances en vivo en siguiente iteraci√≥n)</i>',
    '',
    '<b>üß™ Billetera DEMO</b>',
    '<i>(saldo libre configurable)</i>',
    ''
  ];

  const blocks = [];
  const both = [
    ...topR.map((p,i)=>({mode:'REAL', which:'r', idx:i, text:renderPosition(p)})),
    ...topD.map((p,i)=>({mode:'DEMO', which:'d', idx:i, text:renderPosition(p)}))
  ];

  for (const b of both) {
    blocks.push(b);
  }

  return { text: lines.join('\n'), blocks, totals: m };
}

// Busca posici√≥n en los stores por √≠ndice visual
function getPositionByIndex(bot, uid, which, idx){
  const src = which==='r' ? (bot._store_real?.[uid] || []) : (bot._store_demo?.[uid] || []);
  if (!src.length) return { pos:null, store:src };
  const { list } = which==='r'
    ? { list: src.map((p,i)=>({p,i})) }
    : { list: src.map((p,i)=>({p,i})) };
  // Orden por valor actual no est√° accesible aqu√≠; usamos √≠ndice crudo
  const entry = list[idx];
  if (!entry) return { pos:null, store:src };
  return { pos:entry.p, index:entry.i, store:src };
}

async function handleSell(bot, uid, which, idx, pct, chatId, msgId){
  pct = Math.max(1, Math.min(100, Number(pct)||100));
  const isReal = (which==='r');
  const { pos, index, store } = getPositionByIndex(bot, uid, which, Number(idx));
  if (!pos || pos.qty<=0) throw new Error('Posici√≥n no encontrada');

  // Necesitamos precio actual para info
  const { buildMetrics } = await import('../services/positions.js');
  const m = await buildMetrics({
    storeDemo: which==='d' ? store : [],
    storeReal: which==='r' ? store : [],
    max: store.length
  });
  const arr = (which==='r') ? m.real.list : m.demo.list;
  const rel = arr[index]; // puede no alinear; si no, aproximamos
  const unit = rel?.now || pos.entry || 0;

  const sellQty = pos.qty * (pct/100);

  if (!isReal){
    // DEMO ‚Äî actualizamos store local
    const remaining = pos.qty - sellQty;
    const proceedsUsd = unit * sellQty;

    // Mutar
    if (remaining <= 1e-12) {
      store.splice(index,1);
    } else {
      store[index] = { ...pos, qty: remaining, investedUsd: (remaining*pos.entry) };
    }
    if (which==='d'){ bot._store_demo = bot._store_demo || {}; bot._store_demo[uid] = store; }

    // Log
    try{
      await trading.logTrade?.({
        mode:'DEMO', side:'SELL', symbol: pos.sym || pos.symbol,
        qty: sellQty, priceUsd: unit, proceedsUsd
      });
    }catch{}

    await bot.answerCallbackQuery?.(undefined);
    return { ok:true, txid:null, proceedsUsd };
  }

  // REAL ‚Äî swap via Jupiter
  const owner = process.env.PHANTOM_ADDRESS || '';
  const decimals = Number(pos.decimals ?? 6);
  const atoms = Math.floor(sellQty * 10**decimals);
  const slippageBps = bpsOf(0.8); // 0.8% por defecto

  const res = await sellToUSDC({
    bot, owner, inputMint: (pos.mint || pos.address), amountAtoms: atoms, slippageBps
  });

  // Si sali√≥ bien, reducimos qty local (optimista)
  const remaining = pos.qty - sellQty;
  if (remaining <= 1e-12) {
    store.splice(index,1);
  } else {
    store[index] = { ...pos, qty: remaining, investedUsd: (remaining*pos.entry) };
  }
  bot._store_real = bot._store_real || {}; bot._store_real[uid] = store;

  try{
    await trading.logTrade?.({
      mode:'REAL', side:'SELL', symbol: pos.sym || pos.symbol,
      qty: sellQty, priceUsd: unit, proceedsUsd: unit*sellQty, tx: res.signature
    });
  }catch{}

  return { ok:true, txid: res.signature, proceedsUsd: unit*sellQty };
}

export default function registerWallet(bot){
  bot._walletState = bot._walletState || {};

  // /wallet [seg]|once|stop
  bot.removeTextListener?.(/^\/wallet(?:@[\w_]+)?/i);
  bot.onText(/^\/wallet(?:@[\w_]+)?(?:\s+(stop|once|\d+))?\s*$/i, async (msg, m) => {
    const chatId = msg.chat.id; const uid=String(msg.from.id);
    const arg=(m[1]||'').toLowerCase();

    if (arg==='stop'){
      const st = bot._walletState[uid];
      if (st?.timer){ clearTimeout(st.timer); st.timer=null; }
      return bot.sendMessage(chatId, '‚èπÔ∏è Wallet detenido.', { parse_mode:'HTML' });
    }

    const baseMs = /^\d+$/.test(arg) ? Math.max(3000, Number(arg)*1000) : 6000;

    const makeRender = async ()=>{
      const snap = await snapshot(bot, uid, 10);
      const chunks = [snap.text];
      const keyboards = [];
      for (const b of snap.blocks){
        chunks.push('');
        chunks.push(b.mode==='REAL' ? '<b>‚Äî REAL ‚Äî</b>' : '<b>‚Äî DEMO ‚Äî</b>');
        chunks.push(b.text);
        keyboards.push( b.mode==='REAL'
          ? { kb: null, tag:`r:${b.idx}` } // teclas se agregan en edit
          : { kb: null, tag:`d:${b.idx}` } );
      }
      return { text: chunks.join('\n'), blocks: snap.blocks };
    };

    if (arg==='once'){
      const { text, blocks } = await makeRender();
      const sent = await bot.sendMessage(chatId, text, { parse_mode:'HTML' });
      return;
    }

    const st = bot._walletState[uid] = bot._walletState[uid] || {};
    if (st.timer){ clearTimeout(st.timer); st.timer=null; }

    const first = await makeRender();
    // construimos inline keyboard combinando las de cada bloque (mostrar solo una fila por bloque)
    const rows = [];
    for (const b of first.blocks){
      rows.push([
        { text:'üîÅ 25%', callback_data:`wallet:sell:${b.mode==='REAL'?'r':'d'}:${b.idx}:25` },
        { text:'üîÅ 50%', callback_data:`wallet:sell:${b.mode==='REAL'?'r':'d'}:${b.idx}:50` },
        { text:'üîÅ 75%', callback_data:`wallet:sell:${b.mode==='REAL'?'r':'d'}:${b.idx}:75` },
        { text:'üíØ Vender', callback_data:`wallet:sell:${b.mode==='REAL'?'r':'d'}:${b.idx}:100` },
      ]);
    }
    const replyMarkup = { inline_keyboard: rows.length?rows:[[{text:'‚Äî',callback_data:'wallet:noop'}]] };

    const sent = await bot.sendMessage(chatId, first.text, { parse_mode:'HTML', reply_markup: replyMarkup });
    st.prevText = first.text; st.delayMs=baseMs; st.errors=0;

    const tick = async ()=>{
      if (st.running){ st.timer=setTimeout(tick,jitter(1000)); return; }
      st.running=true;
      let changed=false;
      try{
        const fresh = await makeRender();
        if (fresh.text !== st.prevText){
          // recomponer teclas
          const rows = [];
          for (const b of fresh.blocks){
            rows.push([
              { text:'üîÅ 25%', callback_data:`wallet:sell:${b.mode==='REAL'?'r':'d'}:${b.idx}:25` },
              { text:'üîÅ 50%', callback_data:`wallet:sell:${b.mode==='REAL'?'r':'d'}:${b.idx}:50` },
              { text:'üîÅ 75%', callback_data:`wallet:sell:${b.mode==='REAL'?'r':'d'}:${b.idx}:75` },
              { text:'üíØ Vender', callback_data:`wallet:sell:${b.mode==='REAL'?'r':'d'}:${b.idx}:100` },
            ]);
          }
          const kb = { inline_keyboard: rows.length?rows:[[{text:'‚Äî',callback_data:'wallet:noop'}]] };
          await bot.editMessageText(fresh.text, { chat_id: chatId, message_id: sent.message_id, parse_mode:'HTML', reply_markup: kb });
          st.prevText = fresh.text; changed=true;
        }
        st.errors=0;
      }catch{
        st.errors=Math.min(st.errors+1,10);
      }finally{
        st.running=false;
      }
      st.delayMs = nextDelay({ prevMs: st.delayMs, changed, errorCount: st.errors, baseMs });
      st.timer = setTimeout(tick, st.delayMs);
    };
    st.timer = setTimeout(tick, st.delayMs);
  });

  // Callbacks de venta
  bot.on('callback_query', async (q)=>{
    const d = q.data || '';
    if (!/^wallet:/.test(d)) return;
    const chatId = q.message?.chat?.id;
    const mid = q.message?.message_id;
    const uid = String(q.from.id);

    if (d==='wallet:noop'){ try{ await bot.answerCallbackQuery(q.id); }catch{}; return; }

    const m = d.match(/^wallet:sell:(r|d):(\d+):(\d+)$/);
    if (!m){ try{ await bot.answerCallbackQuery(q.id,{text:'Formato inv√°lido'});}catch{}; return; }
    const which=m[1], idx=m[2], pct=m[3];

    try{
      const res = await handleSell(bot, uid, which, idx, pct, chatId, mid);
      try{ await bot.answerCallbackQuery(q.id, { text: res.txid ? `OK ‚úÖ ${res.txid.slice(0,8)}‚Ä¶` : 'OK ‚úÖ' }); }catch{}
    }catch(e){
      try{ await bot.answerCallbackQuery(q.id, { text: 'Error: '+(e?.message||e), show_alert:true }); }catch{}
    }
  });

  console.log('‚úÖ Handler cargado: wallet.js');
}


// --- Callbacks de venta/cotizaci√≥n (definidos fuera y habilitados una sola vez) ---
async function ensureWalletCallbacks(bot) {
  if (bot._walletCbHandled) return;
  bot._walletCbHandled = true;

  const { sellToUSDC, quoteToUSDC } = await import('../services/swap.js');
  const posMod = await import('../services/positions.js');

  bot.on('callback_query', async (q) => {
    try {
      const data = q?.data || '';
      if (!/^wallet:(sell|quote):/i.test(data)) return;

      const uid    = String(q.from.id);
      const chatId = q.message?.chat?.id || q.message?.chat_id;

      // Formatos: wallet:sell:25:DEMO:SOL[:mint[:qty]]
      const p = data.split(':');
      const action  = (p[1] || 'sell').toLowerCase();
      const percent = Number(p[2] || '100');
      const mode    = (p[3] || 'DEMO').toUpperCase();
      const symbol  = decodeURIComponent((p[4] || '').trim());
      const mint    = p[5] && p[5].length > 0 ? p[5].trim() : undefined;
      let   qty     = p[6] ? Number(p[6]) : NaN;

      const real = (mode === 'REAL') && !!(bot.realMode?.[uid]);

      // Si falta cantidad, intentamos leerla de tus posiciones
      if (!Number.isFinite(qty) || qty <= 0) {
        const get = posMod.getOpenPositions || posMod.readOpenPositions || posMod.listOpenPositions;
        if (typeof get === 'function') {
          const rows = await get({ uid, mode });
          const hit  = Array.isArray(rows)
            ? rows.find(r =>
                (r.symbol && r.symbol.toUpperCase() === symbol.toUpperCase()) ||
                (mint && r.mint && r.mint === mint)
              )
            : null;
          if (hit && Number.isFinite(Number(hit.qty))) qty = Number(hit.qty);
        }
      }

      if (q?.id) { try { await bot.answerCallbackQuery(q.id); } catch {} }

      if (action === 'quote') {
        if (!Number.isFinite(qty) || qty <= 0) {
          return bot.sendMessage(chatId, '‚ö†Ô∏è No tengo cantidad para cotizar. Reabre /wallet y usa el bot√≥n desde la tarjeta.', { parse_mode:'HTML' });
        }
        const qt = await quoteToUSDC({ symbol, mint, qty, percent });
        if (!qt?.ok) return bot.sendMessage(chatId, '‚ö†Ô∏è No se pudo cotizar ahora mismo.', { parse_mode:'HTML' });
        const html = [
          '<b>üìê Cotizaci√≥n</b>',
          `‚Ä¢ Token: <b>${symbol || (mint || '').slice(0,6)+'‚Ä¶'}</b>`,
          `‚Ä¢ Cantidad: <b>${qty}</b>`,
          `‚Ä¢ Vender: <b>${percent}%</b>`,
          qt.priceUsd ? `‚Ä¢ Precio: <b>$${Number(qt.priceUsd).toFixed(6)}</b>` : null,
          qt.toUSDC   ? `‚Ä¢ Recibir ‚âà <b>$${Number(qt.toUSDC).toFixed(2)} USDC</b>` : null,
        ].filter(Boolean).join('\n');
        return bot.sendMessage(chatId, html, { parse_mode:'HTML' });
      }

      // SELL
      if (!Number.isFinite(qty) || qty <= 0) {
        return bot.sendMessage(chatId, '‚ö†Ô∏è No tengo cantidad para vender. Reabre /wallet y usa el bot√≥n desde la tarjeta.', { parse_mode:'HTML' });
      }

      const res = await sellToUSDC({ bot, uid, symbol, mint, qty, percent, real });
      const sim = res?.simulated ? ' (simulado)' : '';
      const html = [
        `<b>‚úÖ Venta${sim} ejecutada</b>`,
        `‚Ä¢ Modo: <b>${real ? 'REAL' : 'DEMO'}</b>`,
        `‚Ä¢ Token: <b>${symbol || (mint || '').slice(0,6)+'‚Ä¶'}</b>`,
        `‚Ä¢ Vendido: <b>${percent}%</b> de <b>${qty}</b>`,
        res?.quote?.priceUsd ? `‚Ä¢ Precio: <b>$${Number(res.quote.priceUsd).toFixed(6)}</b>` : null,
        res?.receivedUSDC ? `‚Ä¢ Recibido: <b>$${Number(res.receivedUSDC).toFixed(2)} USDC</b>` : null,
        res?.txid ? `‚Ä¢ TX: <code>${res.txid}</code>` : null,
      ].filter(Boolean).join('\\n');

      await bot.sendMessage(chatId, html, { parse_mode:'HTML' });
    } catch (e) {
      try { if (q?.id) await bot.answerCallbackQuery(q.id, { text: 'Error' }); } catch {}
      console.error('wallet callback err', e?.message || e);
    }
  });
}
