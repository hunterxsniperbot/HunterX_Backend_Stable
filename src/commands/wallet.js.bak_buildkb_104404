// src/commands/wallet.js — posiciones abiertas (vivo) + vender
import { buildMetrics } from '../services/positions.js';
// Aseguramos también quoteToUSDC para cotizar si hace falta
import { sellToUSDC, quoteToUSDC } from '../services/swap.js';

  // --- callbacks para botones de venta (wallet:sell:xx:MODE:<symbol>[:<mint>[:<qty>]])
import * as trading from '../services/trading.js'; // asume logTrade/logEvent

const sleep = (ms)=> new Promise(r=>setTimeout(r,ms));
function jitter(ms){ return Math.max(1000, Math.floor(ms * (0.9 + Math.random()*0.2))); }
function nextDelay({prevMs, changed, errorCount, baseMs}){
  if (errorCount>0) return Math.min((prevMs||baseMs)*1.5, 30000);
  return changed ? baseMs : Math.min((prevMs||baseMs)+2000, 12000);
}
function fmtUSD(n){ return '$' + (Number(n||0)).toLocaleString('en-US',{minimumFractionDigits:2,maximumFractionDigits:2}); }
function bpsOf(pct){ return Math.round(Number(pct)*100); }

function renderPosition(p){
  const arrow = p.pnlPct>=0 ? '📈' : '📉';
  const name  = p.sym.startsWith('$') ? p.sym : ('$'+p.sym);
  const ds = [
    `🪙 <b>${name}</b>`,
    `📥 Entrada: ${p.entry.toFixed(6)} USD`,
    `📤 Actual: ${p.now.toFixed(6)} USD`,
    `📦 Qty: ${p.qty}`,
    `💵 Invertido: ${fmtUSD(p.invested)}`,
    `${arrow} PnL: <b>${p.pnlPct.toFixed(2)}%</b> (${fmtUSD(p.pnlAbs)})`
  ];
  return ds.join('\n');
}

function buildKeyboard(mode, which, idx){
  // which: 'd' demo, 'r' real — idx: índice visual en la lista mostrada
  const base = `wallet:sell:${which}:${idx}`;
  return {
    inline_keyboard: [
      [
        { text:'🔁 25%', callback_data: `${base}:25` },
        { text:'🔁 50%', callback_data: `${base}:50` },
        { text:'🔁 75%', callback_data: `${base}:75` },
        { text:'💯 Vender', callback_data: `${base}:100` },
      ]
    ]
  };
}

async function snapshot(bot, uid, max=10){
  const storeDemo = bot._store_demo?.[uid] || [];
  const storeReal = bot._store_real?.[uid] || [];
  const m = await buildMetrics({ storeDemo, storeReal, max });

  const topD = m.demo.list;
  const topR = m.real.list;

  const lines = [
    '<b>📱 Posiciones abiertas</b>',
    '',
    `• DEMO: <b>${m.demo.count}</b>`,
    `• REAL: <b>${m.real.count}</b>`,
    `• Total: <b>${m.demo.count + m.real.count}</b>`,
    '',
    '<b>💳 Billetera Phantom (REAL)</b>',
    '<i>(balances en vivo en siguiente iteración)</i>',
    '',
    '<b>🧪 Billetera DEMO</b>',
    '<i>(saldo libre configurable)</i>',
    ''
  ];

  const blocks = [];
  const both = [
    ...topR.map((p,i)=>({mode:'REAL', which:'r', idx:i, text:renderPosition(p)})),
    ...topD.map((p,i)=>({mode:'DEMO', which:'d', idx:i, text:renderPosition(p)}))
  ];

  for (const b of both) {
    blocks.push(b);
  }

  return { text: lines.join('\n'), blocks, totals: m };
}

// Busca posición en los stores por índice visual
function getPositionByIndex(bot, uid, which, idx){
  const src = which==='r' ? (bot._store_real?.[uid] || []) : (bot._store_demo?.[uid] || []);
  if (!src.length) return { pos:null, store:src };
  const { list } = which==='r'
    ? { list: src.map((p,i)=>({p,i})) }
    : { list: src.map((p,i)=>({p,i})) };
  // Orden por valor actual no está accesible aquí; usamos índice crudo
  const entry = list[idx];
  if (!entry) return { pos:null, store:src };
  return { pos:entry.p, index:entry.i, store:src };
}

async function handleSell(bot, uid, which, idx, pct, chatId, msgId){
  pct = Math.max(1, Math.min(100, Number(pct)||100));
  const isReal = (which==='r');
  const { pos, index, store } = getPositionByIndex(bot, uid, which, Number(idx));
  if (!pos || pos.qty<=0) throw new Error('Posición no encontrada');

  // Necesitamos precio actual para info
  const { buildMetrics } = await import('../services/positions.js');
  const m = await buildMetrics({
    storeDemo: which==='d' ? store : [],
    storeReal: which==='r' ? store : [],
    max: store.length
  });
  const arr = (which==='r') ? m.real.list : m.demo.list;
  const rel = arr[index]; // puede no alinear; si no, aproximamos
  const unit = rel?.now || pos.entry || 0;

  const sellQty = pos.qty * (pct/100);

  if (!isReal){
    // DEMO — actualizamos store local
    const remaining = pos.qty - sellQty;
    const proceedsUsd = unit * sellQty;

    // Mutar
    if (remaining <= 1e-12) {
      store.splice(index,1);
    } else {
      store[index] = { ...pos, qty: remaining, investedUsd: (remaining*pos.entry) };
    }
    if (which==='d'){ bot._store_demo = bot._store_demo || {}; bot._store_demo[uid] = store; }

    // Log
    try{
      await trading.logTrade?.({
        mode:'DEMO', side:'SELL', symbol: pos.sym || pos.symbol,
        qty: sellQty, priceUsd: unit, proceedsUsd
      });
    }catch{}

    await bot.answerCallbackQuery?.(undefined);
    return { ok:true, txid:null, proceedsUsd };
  }

  // REAL — swap via Jupiter
  const owner = process.env.PHANTOM_ADDRESS || '';
  const decimals = Number(pos.decimals ?? 6);
  const atoms = Math.floor(sellQty * 10**decimals);
  const slippageBps = bpsOf(0.8); // 0.8% por defecto

  const res = await sellToUSDC({
    bot, owner, inputMint: (pos.mint || pos.address), amountAtoms: atoms, slippageBps
  });

  // Si salió bien, reducimos qty local (optimista)
  const remaining = pos.qty - sellQty;
  if (remaining <= 1e-12) {
    store.splice(index,1);
  } else {
    store[index] = { ...pos, qty: remaining, investedUsd: (remaining*pos.entry) };
  }
  bot._store_real = bot._store_real || {}; bot._store_real[uid] = store;

  try{
    await trading.logTrade?.({
      mode:'REAL', side:'SELL', symbol: pos.sym || pos.symbol,
      qty: sellQty, priceUsd: unit, proceedsUsd: unit*sellQty, tx: res.signature
    });
  }catch{}

  return { ok:true, txid: res.signature, proceedsUsd: unit*sellQty };
}

export default function registerWallet(bot){
  // asegura callbacks de venta/cotización
  ensureWalletCallbacks(bot);
  bot._walletState = bot._walletState || {};

  // /wallet [seg]|once|stop
  bot.removeTextListener?.(/^\/wallet(?:@[\w_]+)?/i);
  bot.onText(/^\/wallet(?:@[\w_]+)?(?:\s+(stop|once|\d+))?\s*$/i, async (msg, m) => {
    const chatId = msg.chat.id; const uid=String(msg.from.id);
    const arg=(m[1]||'').toLowerCase();

    if (arg==='stop'){
      const st = bot._walletState[uid];
      if (st?.timer){ clearTimeout(st.timer); st.timer=null; }
      return bot.sendMessage(chatId, '⏹️ Wallet detenido.', { parse_mode:'HTML' });
    }

    const baseMs = /^\d+$/.test(arg) ? Math.max(3000, Number(arg)*1000) : 6000;

    const makeRender = async ()=>{
      const snap = await snapshot(bot, uid, 10);
      const chunks = [snap.text];
      const keyboards = [];
      for (const b of snap.blocks){
        chunks.push('');
        chunks.push(b.mode==='REAL' ? '<b>— REAL —</b>' : '<b>— DEMO —</b>');
        chunks.push(b.text);
        keyboards.push( b.mode==='REAL'
          ? { kb: null, tag:`r:${b.idx}` } // teclas se agregan en edit
          : { kb: null, tag:`d:${b.idx}` } );
      }
      return { text: chunks.join('\n'), blocks: snap.blocks };
    };

    if (arg==='once'){
      const { text, blocks } = await makeRender();
      const sent = await bot.sendMessage(chatId, text, { parse_mode:'HTML' });
      return;
    }

    const st = bot._walletState[uid] = bot._walletState[uid] || {};
    if (st.timer){ clearTimeout(st.timer); st.timer=null; }

    const first = await makeRender();
    // construimos inline keyboard combinando las de cada bloque (mostrar solo una fila por bloque)
    const rows = [];
    for (const b of first.blocks){
      rows.push([
        { text:'🔁 25%', callback_data:`wallet:sell:${b.mode==='REAL'?'r':'d'}:${b.idx}:25` },
        { text:'🔁 50%', callback_data:`wallet:sell:${b.mode==='REAL'?'r':'d'}:${b.idx}:50` },
        { text:'🔁 75%', callback_data:`wallet:sell:${b.mode==='REAL'?'r':'d'}:${b.idx}:75` },
        { text:'💯 Vender', callback_data:`wallet:sell:${b.mode==='REAL'?'r':'d'}:${b.idx}:100` },
      ]);
    }
    const replyMarkup = { inline_keyboard: rows.length?rows:[[{text:'—',callback_data:'wallet:noop'}]] };

    const sent = await bot.sendMessage(chatId, first.text, { parse_mode:'HTML', reply_markup: replyMarkup });
    st.prevText = first.text; st.delayMs=baseMs; st.errors=0;

    const tick = async ()=>{
      if (st.running){ st.timer=setTimeout(tick,jitter(1000)); return; }
      st.running=true;
      let changed=false;
      try{
        const fresh = await makeRender();
        if (fresh.text !== st.prevText){
          // recomponer teclas
          const rows = [];
          for (const b of fresh.blocks){
            rows.push([
              { text:'🔁 25%', callback_data:`wallet:sell:${b.mode==='REAL'?'r':'d'}:${b.idx}:25` },
              { text:'🔁 50%', callback_data:`wallet:sell:${b.mode==='REAL'?'r':'d'}:${b.idx}:50` },
              { text:'🔁 75%', callback_data:`wallet:sell:${b.mode==='REAL'?'r':'d'}:${b.idx}:75` },
              { text:'💯 Vender', callback_data:`wallet:sell:${b.mode==='REAL'?'r':'d'}:${b.idx}:100` },
            ]);
          }
          const kb = { inline_keyboard: rows.length?rows:[[{text:'—',callback_data:'wallet:noop'}]] };
          await bot.editMessageText(fresh.text, { chat_id: chatId, message_id: sent.message_id, parse_mode:'HTML', reply_markup: kb });
          st.prevText = fresh.text; changed=true;
        }
        st.errors=0;
      }catch{
        st.errors=Math.min(st.errors+1,10);
      }finally{
        st.running=false;
      }
      st.delayMs = nextDelay({ prevMs: st.delayMs, changed, errorCount: st.errors, baseMs });
      st.timer = setTimeout(tick, st.delayMs);
    };
    st.timer = setTimeout(tick, st.delayMs);
  });

  // Callbacks de venta
  bot.on('callback_query', async (q)=>{
    const d = q.data || '';
    if (!/^wallet:/.test(d)) return;
    const chatId = q.message?.chat?.id;
    const mid = q.message?.message_id;
    const uid = String(q.from.id);

    if (d==='wallet:noop'){ try{ await bot.answerCallbackQuery(q.id); }catch{}; return; }

    const m = d.match(/^wallet:sell:(r|d):(\d+):(\d+)$/);
    if (!m){ try{ await bot.answerCallbackQuery(q.id,{text:'Formato inválido'});}catch{}; return; }
    const which=m[1], idx=m[2], pct=m[3];

    try{
      const res = await handleSell(bot, uid, which, idx, pct, chatId, mid);
      try{ await bot.answerCallbackQuery(q.id, { text: res.txid ? `OK ✅ ${res.txid.slice(0,8)}…` : 'OK ✅' }); }catch{}
    }catch(e){
      try{ await bot.answerCallbackQuery(q.id, { text: 'Error: '+(e?.message||e), show_alert:true }); }catch{}
    }
  });

  console.log('✅ Handler cargado: wallet.js');
}


// --- Callbacks de venta/cotización (definidos fuera y habilitados una sola vez) ---

// --- Callbacks de venta/cotización (definidos fuera y habilitados una sola vez) ---
async function ensureWalletCallbacks(bot) {
  if (bot._walletCbHandled) return;
  bot._walletCbHandled = true;

  const { sellToUSDC, quoteToUSDC } = await import('../services/swap.js');
  const posMod = await import('../services/positions.js');

  bot.on('callback_query', async (q) => {
    try {
      const data = q?.data || '';
      if (!/^wallet:(sell|quote):/i.test(data)) return;

      const uid    = String(q.from.id);
      const chatId = q.message?.chat?.id || q.message?.chat_id;

      // Formato: wallet:sell:25:DEMO:SYM[:mint[:qty]]
      const p = data.split(':');
      const action  = (p[1] || 'sell').toLowerCase();
      const percent = Number(p[2] || '100');
      const mode    = (p[3] || 'DEMO').toUpperCase();
      const symbol  = decodeURIComponent((p[4] || '').trim());
      const mint    = p[5] && p[5].length > 0 ? p[5].trim() : undefined;
      let   qty     = p[6] ? Number(p[6]) : NaN;

      const real = (mode === 'REAL') && !!(bot.realMode?.[uid]);

      // Completar qty leyendo posiciones si falta
      if (!Number.isFinite(qty) || qty <= 0) {
        const get = posMod.getOpenPositions || posMod.readOpenPositions || posMod.listOpenPositions;
        if (typeof get === 'function') {
          const rows = await get({ uid, mode });
          const hit  = Array.isArray(rows)
            ? rows.find(r =>
                (r.symbol && r.symbol.toUpperCase() === symbol.toUpperCase()) ||
                (mint && r.mint && r.mint === mint)
              )
            : null;
          if (hit && Number.isFinite(Number(hit.qty))) qty = Number(hit.qty);
        }
      }

      if (q?.id) { try { await bot.answerCallbackQuery(q.id); } catch {} }

      if (action === 'quote') {
        if (!Number.isFinite(qty) || qty <= 0) {
          return bot.sendMessage(chatId, '⚠️ No tengo cantidad para cotizar. Reabrí /wallet y usá el botón desde la tarjeta.', { parse_mode:'HTML' });
        }
        const qt = await quoteToUSDC({ symbol, mint, qty, percent });
        if (!qt?.ok) return bot.sendMessage(chatId, '⚠️ No se pudo cotizar ahora mismo.', { parse_mode:'HTML' });

        const html = [
          '<b>📐 Cotización</b>',
          '• Token: <b>' + (symbol || ((mint || '').slice(0,6) + '…')) + '</b>',
          '• Cantidad: <b>' + qty + '</b>',
          '• Vender: <b>' + percent + '%</b>',
          (qt.priceUsd != null ? ('• Precio: <b>$' + Number(qt.priceUsd).toFixed(6) + '</b>') : null),
          (qt.toUSDC   != null ? ('• Recibir ≈ <b>$' + Number(qt.toUSDC).toFixed(2) + ' USDC</b>') : null),
        ].filter(Boolean).join('\n');
        return bot.sendMessage(chatId, html, { parse_mode:'HTML' });
      }

      // SELL
      if (!Number.isFinite(qty) || qty <= 0) {
        return bot.sendMessage(chatId, '⚠️ No tengo cantidad para vender. Reabrí /wallet y usá el botón desde la tarjeta.', { parse_mode:'HTML' });
      }

      const res = await sellToUSDC({ bot, uid, symbol, mint, qty, percent, real });
      const sim = res?.simulated ? ' (simulado)' : '';
      const html = [
        '<b>✅ Venta' + sim + ' ejecutada</b>',
        '• Modo: <b>' + (real ? 'REAL' : 'DEMO') + '</b>',
        '• Token: <b>' + (symbol || ((mint || '').slice(0,6) + '…')) + '</b>',
        '• Vendido: <b>' + percent + '%</b> de <b>' + qty + '</b>',
        (res?.quote?.priceUsd != null ? ('• Precio: <b>$' + Number(res.quote.priceUsd).toFixed(6) + '</b>') : null),
        (res?.receivedUSDC != null ? ('• Recibido: <b>$' + Number(res.receivedUSDC).toFixed(2) + ' USDC</b>') : null),
        (res?.txid ? ('• TX: <code>' + res.txid + '</code>') : null),
      ].filter(Boolean).join('\n');

      await bot.sendMessage(chatId, html, { parse_mode:'HTML' });
    } catch (e) {
      try { if (q?.id) await bot.answerCallbackQuery(q.id, { text: 'Error' }); } catch {}
      console.error('wallet callback err', e?.message || e);
    }
  });
}
