// src/commands/health.js ‚Äî Health ‚Äúvivo‚Äù con auto-refresh adaptativo (HTML)
const OK  = '‚úÖ';
const BAD = '‚ùå';

const I = {
  infra: 'üõ∞Ô∏è',
  tg: 'ü§ñ',
  qn: 'üîå',
  phantom: 'ü™™',
  supabase: 'üóÉÔ∏è',
  sheets: 'üìÑ',
  render: 'üöÄ',

  data: 'üì°',
  dexscreener: 'üìä',
  birdeye: 'ü¶Ö',
  tokensniffer: 'üïµÔ∏è',
  whale: 'üêã',
  tf: 'üß†',
  solscan: 'üî¶',
  jupiter: 'ü™ê',
  raydium: 'üí†',
  gecko: 'ü¶é',
  cmc: 'ü™ô',
  discord: 'üí¨',
};

function esc(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
const sleep = (ms)=> new Promise(r=>setTimeout(r,ms));

// fetch con timeout corto
async function ping(url, { method='GET', headers={}, body, timeoutMs=2500 } = {}) {
  try {
    const res = await fetch(url, { method, headers, body, signal: AbortSignal.timeout(timeoutMs) });
    return res.ok;
  } catch { return false; }

// --------- PROBES ‚Äúreales‚Äù (o heur√≠sticos si falta API key) ---------
async function checkQuickNode() {
  const url = process.env.QUICKNODE_HTTP || process.env.QUICKNODE_RPC_URL || process.env.RPC_URL;
  if (!url) return false;
  try {
    const res = await fetch(url, {
      method: 'POST',
      headers: { 'content-type':'application/json' },
      body: JSON.stringify({ jsonrpc:'2.0', id:1, method:'getHealth' }),
      signal: AbortSignal.timeout(2500),
    });
    if (!res.ok) return false;
    const j = await res.json().catch(()=>null);
    return j?.result === 'ok' || !!j;
  } catch { return false; }
}

async function checkPhantom(bot) { return !!bot._phantomClient; }

async function checkSupabase() {
  const url = process.env.SUPABASE_URL;
  const key = process.env.SUPABASE_ANON_KEY;
  if (!url || !key) return false;
  return ping(`${url.replace(/\/+$/,'')}/auth/v1/health`, { headers: { apikey: key }, timeoutMs: 2500 });
}

async function checkSheets() {
  const id = process.env.GOOGLE_SHEETS_ID || process.env.SHEETS_ID || process.env.GSHEET_ID;
  const svc = process.env.GOOGLE_SERVICE_ACCOUNT_EMAIL && process.env.GOOGLE_PRIVATE_KEY;
  return !!(id && svc);
}

async function checkRender() { return !!(process.env.RENDER || process.env.RENDER_EXTERNAL_URL); }

// --------- Fuentes de datos ---------
async function checkDexScreener() { return ping('https://api.dexscreener.com/latest/dex/search?q=sol', { timeoutMs: 2500 }); }
async function checkBirdeye() {
  const key = process.env.BIRDEYE_API_KEY || process.env.BIRD_EYE_API_KEY;
  if (!key) return false;
  return ping('https://public-api.birdeye.so/defi/price?address=So11111111111111111111111111111111111111112',
              { headers: { 'X-API-KEY': key }, timeoutMs: 2500 });
}
async function checkTokenSniffer() { return ping('https://tokensniffer.com', { timeoutMs: 2500 }); }
async function checkWhaleAlert() {
  const key = process.env.WHALE_ALERT_API_KEY || process.env.WHALEALERT_API_KEY;
  if (!key) return false;
  return ping(`https://api.whale-alert.io/v1/status?api_key=${encodeURIComponent(key)}`, { timeoutMs: 2500 });
}
async function checkTF() {
  try {
    const tf = await import('@tensorflow/tfjs-node').catch(()=>null) || await import('@tensorflow/tfjs').catch(()=>null);
    return !!tf;
  } catch { return false; }
}
async function checkSolscan() { return ping('https://public-api.solscan.io/chaininfo', { timeoutMs: 2500 }); }
async function checkJupiter() { return ping('https://price.jup.ag/v4/price?ids=SOL', { timeoutMs: 2500 }); }
async function checkRaydium() { return ping('https://api.raydium.io/pairs', { timeoutMs: 2500 }); }
async function checkGecko()   { return ping('https://api.coingecko.com/api/v3/ping', { timeoutMs: 2500 }); }
async function checkCMC() {
  const key = process.env.CMC_API_KEY || process.env.COINMARKETCAP_API_KEY;
  if (!key) return false;
  return ping('https://pro-api.coinmarketcap.com/v1/key/info', {
    headers: { 'X-CMC_PRO_API_KEY': key }, timeoutMs: 2500
  });
}
async function checkDiscord() { return !!process.env.DISCORD_TOKEN; }

// --------- Renderizador del panel ---------
async function snapshot(bot) {
  const tgMode = 'POLLING';
  const [
    qn, ph, sb, sh, rn,
    dx, be, ts, wa, tf,
    ss, jp, ry, cg, cmc, dc
  ] = await Promise.all([
    checkQuickNode(),
    checkPhantom(bot),
    checkSupabase(),
    checkSheets(),
    checkRender(),

    checkDexScreener(),
    checkBirdeye(),
    checkTokenSniffer(),
    checkWhaleAlert(),
    checkTF(),

    checkSolscan(),
    checkJupiter(),
    checkRaydium(),
    checkGecko(),
    checkCMC(),
    checkDiscord(),
  ]);

  const lines = [
    `<b>${I.infra} Estado HunterX</b>`,
    '',
    '<b>Infraestructura</b>',
    `${I.tg} TG mode: <b>${esc(tgMode)}</b>`,
    `${I.qn} QuickNode: ${qn?OK:BAD}`,
    `${I.phantom} Phantom: ${ph?OK:BAD}`,
    `${I.supabase} Supabase: ${sb?OK:BAD}`,
    `${I.sheets} Google Sheets: ${sh?OK:BAD}`,
    `${I.render} Render: ${rn?OK:BAD}`,
    '',
    '<b>Fuentes de datos</b>',
    `${I.dexscreener} DexScreener: ${dx?OK:BAD}`,
    `${I.birdeye} Birdeye: ${be?OK:BAD}`,
    `${I.tokensniffer} TokenSniffer: ${ts?OK:BAD}`,
    `${I.whale} Whale Alert: ${wa?OK:BAD}`,
    `${I.tf} TensorFlow IA: ${tf?OK:BAD}`,
    `${I.solscan} Solscan: ${ss?OK:BAD}`,
    `${I.jupiter} Jupiter: ${jp?OK:BAD}`,
    `${I.raydium} Raydium: ${ry?OK:BAD}`,
    `${I.gecko} CoinGecko: ${cg?OK:BAD}`,
    `${I.cmc} CoinMarketCap: ${cmc?OK:BAD}`,
    `${I.discord} Discord: ${dc?OK:BAD}`,
  ];
  return lines.join('\n');
}

// ---------- Scheduler ADAPTATIVO (indefinido, liviano) -------------
function jitter(ms) {
  // +/-10% para evitar sincronizaci√≥n
  const f = 1 + (Math.random()*0.2 - 0.1);
  return Math.round(ms * f);
}

function nextDelay({ prevMs, changed, errorCount, baseMs, minMs=5000, maxIdleMs=60000, maxErrMs=120000 }) {
  if (errorCount > 0) {
    // backoff exponencial con tope
    const doubled = Math.min(maxErrMs, Math.max(baseMs, prevMs * 2));
    return jitter(doubled);
  }
  if (changed) {
    // hubo cambios ‚Üí volvemos al base
    return jitter(Math.max(minMs, baseMs));
  }
  // sin cambios ‚Üí crecemos suave hasta 60s
  const grown = Math.min(maxIdleMs, Math.round(prevMs + Math.max(2000, baseMs * 0.5)));
  return jitter(Math.max(minMs, grown));
}

// === HunterX: helpers de infraestructura ===
import { getConnection, isValidSolAddress, getSolBalance } from '../services/solana.js';


  const sheetsOk = process.env.GOOGLE_SHEETS_ID ? '‚úÖ' : '‚ùå';
  const renderOk = '‚ùå';

  // Devuelve bloque HTML listo para pegar en el mensaje
  return [
    '<b>Infraestructura</b>',
    '<pre>',
    '‚Ä¢ TG mode: POLLING',
    `‚Ä¢ QuickNode: ${quickNodeOk}`,
    `‚Ä¢ Phantom: ${phantomLine}`,
    `‚Ä¢ Google Sheets: ${sheetsOk}`,
    `‚Ä¢ Render: ${renderOk}`,
    '</pre>',
  ].join('\\n');
}
// === Secciones HTML para /health (usa los checks ya definidos) ===
async function buildInfraSection(bot){
  const qn = (await checkQuickNode()) ? OK : BAD;
  const ph = (await checkPhantom(bot)) ? OK : BAD;
  const sp = (await checkSupabase())  ? OK : BAD;
  const sh = (await checkSheets())    ? OK : BAD;
  const rd = (await checkRender())    ? OK : BAD;

  const lines = [
    '<b>Infraestructura</b>',
    '<pre>',
    `‚Ä¢ TG mode: POLLING`,
    `${I.qn} QuickNode: ${qn}`,
    `${I.phantom} Phantom: ${ph}`,
    `${I.supabase} Supabase: ${sp}`,
    `${I.sheets} Google Sheets: ${sh}`,
    `${I.render} Render: ${rd}`,
    '</pre>',
  ];
  return lines.join('\n');
}

async function buildDataSection(){
  const ds = (await checkDexScreener()) ? OK : BAD;
  const be = (await checkBirdeye())     ? OK : BAD;
  const ts = (typeof checkTokenSniffer==='function' ? await checkTokenSniffer() : false) ? OK : BAD;
  const wh = (typeof checkWhaleAlert==='function'  ? await checkWhaleAlert()   : false) ? OK : BAD;
  const tf = (typeof checkTensorFlow==='function'  ? await checkTensorFlow()   : false) ? OK : BAD;
  const ss = (typeof checkSolscan==='function'     ? await checkSolscan()      : false) ? OK : BAD;
  const jp = (typeof checkJupiter==='function'     ? await checkJupiter()      : false) ? OK : BAD;
  const ry = (typeof checkRaydium==='function'     ? await checkRaydium()      : false) ? OK : BAD;
  const cg = (typeof checkCoinGecko==='function'   ? await checkCoinGecko()    : false) ? OK : BAD;
  const cm = (typeof checkCMC==='function'         ? await checkCMC()          : false) ? OK : BAD;
  const dc = (typeof checkDiscord==='function'     ? await checkDiscord()      : false) ? OK : BAD;

  const lines = [
    '<b>Fuentes de datos</b>',
    '<pre>',
    `${I.dexscreener} DexScreener: ${ds}`,
    `${I.birdeye} Birdeye: ${be}`,
    `${I.tokensniffer} TokenSniffer: ${ts}`,
    `${I.whale} Whale Alert: ${wh}`,
    `${I.tf} TensorFlow IA: ${tf}`,
    `${I.solscan} Solscan: ${ss}`,
    `${I.jupiter} Jupiter: ${jp}`,
    `${I.raydium} Raydium: ${ry}`,
    `${I.gecko} CoinGecko: ${cg}`,
    `${I.cmc} CoinMarketCap: ${cm}`,
    `${I.discord} Discord: ${dc}`,
    '</pre>',
  ];
  return lines.join('\n');
}
export default function registerHealth(bot) {
  bot._healthState = bot._healthState || {}; // por uid: {timer, running, prevText, delayMs, errors}
  // /health [seg] | /health once | /health stop
  bot.removeTextListener?.(/^\/health(?:@[\w_]+)?/i);
  bot.onText(/^\/health(?:@[\w_]+)?(?:\s+(stop|once|\d+))?\s*$/i, async (msg, m) => {
    const chatId = msg.chat.id;
    const uid    = String(msg.from.id);
    const arg    = (m && m[1]) ? m[1].toLowerCase() : '';
    const baseSec = (arg && /^\d+$/.test(arg)) ? Number(arg) : 10; // default 10s
    const baseMs  = Math.max(3000, Math.min(60000, baseSec * 1000));

    const st = bot._healthState[uid] = bot._healthState[uid] || { timer:null, running:false, prevText:'', delayMs:baseMs, errors:0 };

    // STOP
    if (arg === 'stop') {
      if (st.timer) { clearTimeout(st.timer); st.timer=null; }
      return bot.sendMessage(chatId, '‚èπÔ∏è Auto-refresh detenido.', { parse_mode:'HTML' });
    }

    // ONE-SHOT
    if (arg === 'once') {
      const text = await snapshot(bot);
      return bot.sendMessage(chatId, text, { parse_mode:'HTML' });
    }

    // arranque: primer mensaje
    const first = await snapshot(bot);
    const replyMarkup = {
      inline_keyboard: [[
        { text: `üîÑ base ${Math.round(baseMs/1000)}s`, callback_data: 'health:noop' },
        { text: '‚èπÔ∏è Parar', callback_data: 'health:stop' },
      ]]
    };
      {
        const __infra = await buildInfraSection(bot);
        const __data  = await buildDataSection();
        first = [first, __infra, __data].filter(Boolean).join('\n');
      }
    const sent = await bot.sendMessage(chatId, first, { parse_mode:'HTML', reply_markup: replyMarkup });
    st.prevText = first;
    st.delayMs  = baseMs;
    st.errors   = 0;

    // cancelar loop previo si hubiera
    if (st.timer) { clearTimeout(st.timer); st.timer=null; }

    // Loop recursivo con setTimeout (permite delay adaptativo)
    const tick = async () => {
      if (st.running) { // anti-reentrancia
        st.timer = setTimeout(tick, jitter(1000));
        return;
      }
      st.running = true;
          {
            const __infra = await buildInfraSection(bot);
            const __data  = await buildDataSection();
            fresh = [fresh, __infra, __data].filter(Boolean).join('\n');
          }
      let changed = false;
      try {
        const fresh = await snapshot(bot);
        if (fresh !== st.prevText) {
          // editar solo si cambi√≥
          await bot.editMessageText(fresh, { chat_id: chatId, message_id: sent.message_id, parse_mode:'HTML', reply_markup: replyMarkup });
          st.prevText = fresh;
          changed = true;
        }
        st.errors = 0;
      } catch {
        st.errors = Math.min(st.errors + 1, 10);
      } finally {
        st.running = false;
      }
      st.delayMs = nextDelay({ prevMs: st.delayMs, changed, errorCount: st.errors, baseMs });
      st.timer = setTimeout(tick, st.delayMs);
    };

    st.timer = setTimeout(tick, st.delayMs);
  });

  // callbacks (parar / noop)
  bot.on('callback_query', async (q) => {
    const data = q.data || '';
    if (!/^health:/.test(data)) return;
    const uid = String(q.from.id);
    const st  = bot._healthState?.[uid];
    if (data === 'health:stop') {
      if (st?.timer) { clearTimeout(st.timer); st.timer=null; }
      try { await bot.answerCallbackQuery(q.id, { text: 'Auto-refresh detenido.' }); } catch {}
    } else {
      try { await bot.answerCallbackQuery(q.id); } catch {}
    }
  });

  console.log('‚úÖ Handler cargado: health.js (live/adaptativo)');
  const __infra = await buildInfraSection();
  if (typeof html !== 'undefined') html = (html ? html + '\n' : '') + __infra;
  if (typeof text !== 'undefined') text = (text ? text + '\n' : '') + __infra;
}
