/**
 * M4 Selector (DEMO) — sin variables fantasma
 * - Selecciona candidato desde marketsPref (Gecko/Raydium)
 * - Aplica umbrales mínimos (liq/fdv)
 * - Si pasa, ejecuta demoBuyOnce(size, symbol) y devuelve objeto {ok:true,...}
 */

import * as markets from "../services/marketsPref.js";

// Defaults leíbles desde ENV (con fallback razonable)
const ENV = {
  SIZE:      clampNum(process.env.SNIPER_BASE_DEMO_USD, 20, 1, 2000),  // cuánto comprar en DEMO
  MIN_LIQ:   clampNum(process.env.M4_MIN_LIQ_USD,       150000, 1000, 1_000_000),
  MAX_FDV:   clampNum(process.env.M4_MAX_FDV_USD,       300000, 5000,  50_000_000),
  LIMIT:     clampNum(process.env.M4_FEED_LIMIT,        40, 5, 200),
};

function clampNum(v, def, min, max){
  const n = Number(v); 
  if (Number.isFinite(n)) return Math.max(min, Math.min(n, max));
  return def;
}

/**
 * pickCandidate: trae pares y elige uno que pase umbrales.
 * Devuelve: { ok:true, symbol, liq, fdv, priceUsd } o { ok:false, reason }
 */
export async function pickCandidate(opts = {}) {
  const limit  = Number(opts.limit  ?? ENV.LIMIT);
  const minLiq = Number(opts.minLiq ?? ENV.MIN_LIQ);
  const maxFdv = Number(opts.maxFdv ?? ENV.MAX_FDV);

  let pairs = [];
  try {
    pairs = await markets.getSolanaPairs({ limit });
  } catch (e) {
    return { ok:false, reason:"feed_error", error:String(e?.message||e) };
  }

  if (!Array.isArray(pairs) || pairs.length === 0) {
    return { ok:false, reason:"no_pairs" };
  }

  // Normalizamos y filtramos
  const norm = pairs.map(p => ({
    source: p.source || 'gecko',
    symbol: (p.baseSymbol || p.symbol || '?').toString(),
    liq:    Number(p.liquidityUsd ?? p.liquidityUSD ?? 0),
    fdv:    Number(p.fdvUsd ?? p.fdvUSD ?? 0),
    price:  Number(p.priceUsd ?? p.priceUSD ?? 0),
  })).filter(x => Number.isFinite(x.liq) && Number.isFinite(x.fdv));

  // Umbrales
  const filtered = norm.filter(x =>
    x.liq >= minLiq && (x.fdv === 0 || x.fdv <= maxFdv)
  );

  if (filtered.length === 0) {
    return { ok:false, reason:"no_candidate_threshold" };
  }

  // Orden simple (más liquidez primero), podes cambiar a criterio mixto más adelante
  filtered.sort((a,b) => b.liq - a.liq);

  const top = filtered[0];
  return { ok:true, symbol: top.symbol, liq: top.liq, fdv: top.fdv, priceUsd: top.price, source: top.source };
}

/**
 * maybeAutoBuyDemo: si hay candidato, ejecuta DEMO y devuelve el resultado.
 * Espera en options: { demoBuyOnce } función async (amountUsd, symbol)
 */
export async function maybeAutoBuyDemo(bot, uid, options = {}) {
  const demoBuyOnce = options.demoBuyOnce;
  if (typeof demoBuyOnce !== 'function') {
    return { ok:false, reason:"no_demo_buy_func" };
  }

  const sel = await pickCandidate();
  if (!sel.ok) {
    // No hay candidato válido ahora
    return sel; // {ok:false, reason:...}
  }

  const sym  = sel.symbol || '?';
  const size = ENV.SIZE;

  try {
    // Ejecutar compra DEMO
    const trade = await demoBuyOnce(size, sym);
    // Log visible de consola
    console.log(`[M4] DEMO buy ${sym}  $${size} liq=$${(sel.liq||0).toFixed(4)} fdv=$${(sel.fdv||0).toFixed(5)}`);
    // Resultado estándar
    return { ok:true, trade, symbol:sym, size, liq:sel.liq, fdv:sel.fdv, priceUsd:sel.priceUsd };
  } catch (e) {
    return { ok:false, reason:"demo_buy_fail", error:String(e?.message||e) };
  }
}
