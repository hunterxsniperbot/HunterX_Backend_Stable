import http from 'node:http';
import url  from 'node:url';
import crypto from 'node:crypto';
import { loadState, saveState } from '../services/state_compat.js';
import { getPriceUSD } from '../services/prices.js';
import { runHealthChecks } from '../services/health_checks.js';

const PORT = Number(process.env.API_PORT || 3000);
const RESIDUAL_USD = Number(process.env.WALLET_RESIDUAL_USD || 1.00);
const WALLET_REFRESH_MS = Number(process.env.WALLET_REFRESH_MS || 2000);

const IDEMP = new Map();   // actionId -> ts
const LOCKS = new Map();   // posId -> ts

function now(){ return Date.now(); }
function fmtUsd(n){ return Number(n||0).toLocaleString('en-US',{style:'currency',currency:'USD',minimumFractionDigits:2,maximumFractionDigits:2}); }
function fmtPct(x){ return `${(Number(x)||0).toFixed(1)}%`; }

async function jsonBody(req){
  const chunks=[]; for await (const c of req) chunks.push(c);
  const raw = Buffer.concat(chunks).toString('utf8') || '{}';
  try{ return JSON.parse(raw); } catch { return {}; }
}

async function pricesFor(mints){
  const out=new Map();
  await Promise.all(mints.map(async m=>{
    try{
      const r = await getPriceUSD(m);
      out.set(m, Number(r?.price||r||0));
    }catch{
      out.set(m, 0);
    }
  }));
  return out;
}

function posPnl(pos, price){
  const entry=Number(pos.entryPriceUsd||0), inv=Number(pos.investedUsd||0);
  if(entry<=0 || inv<=0 || price<=0) return {usd:0, pct:0};
  const pct = (price/entry - 1) * 100;
  const usd = (pct/100) * inv;
  return {usd, pct};
}

function labelForPiece(invUsd, entry, price, frac){
  if(invUsd<=0 || entry<=0 || price<=0) return `NA`;
  // aproximamos el valor de la pieza al precio actual
  const pieceValue = invUsd * frac * (price/entry);
  const pnlPiece   = (price/entry - 1) * 100 * (invUsd*frac)/100; // no usamos en texto, queda confuso
  return `${Math.round(frac*100)}% (${fmtUsd(pieceValue)})`;
}

function buttonsFor(pos, price){
  const inv = Number(pos.investedUsd||0);
  const entry = Number(pos.entryPriceUsd||0);
  const left = (frac)=> inv*(1-frac);
  const rem = (x)=> x < RESIDUAL_USD;

  const id = pos.id;
  const b25 = labelForPiece(inv, entry, price, 0.25);
  const b50 = labelForPiece(inv, entry, price, 0.50);
  const b75 = labelForPiece(inv, entry, price, 0.75);
  const showRema = rem(left(0.25)) || rem(left(0.50)) || rem(left(0.75));

  return {
    b25:  { label: b25,                 data: `sell:${id}:25`  },
    b50:  { label: b50,                 data: `sell:${id}:50`  },
    b75:  { label: b75,                 data: `sell:${id}:75`  },
    b100: { label: showRema?'üíØ Resto':'üíØ Vender todo', data: `sell:${id}:100`, isRemainder: showRema }
  };
}

async function computeWallet(mode){
  const st = loadState();
  st.positions = st.positions || {};
  const arr = Array.isArray(st.positions[mode]) ? st.positions[mode] : [];
  const open = arr.filter(p=>p.isOpen!==false && Number(p.investedUsd||0)>0);

  // precios
  const mints = [...new Set(open.map(p=>String(p.mint)))];
  const px = await pricesFor(mints);

  // balances base USD (demo y real por separado)
  const sumInvDemo = (Array.isArray(st.positions.demo)? st.positions.demo:[]).filter(p=>p.isOpen!==false).reduce((a,p)=>a+Number(p.investedUsd||0),0);
  const sumInvReal = (Array.isArray(st.positions.real)? st.positions.real:[]).filter(p=>p.isOpen!==false).reduce((a,p)=>a+Number(p.investedUsd||0),0);

  st.demo = st.demo || {};
  st.real = st.real || {};
  if (typeof st.demo.cash !== 'number') st.demo.cash = Math.max(0, 10_000 - sumInvDemo);
  if (typeof st.real.cash !== 'number') st.real.cash = 0;

  const balances = {
    demo: { investedUsd: +sumInvDemo.toFixed(2), cashUsd: +Number(st.demo.cash||0).toFixed(2), totalUsd: +(sumInvDemo + Number(st.demo.cash||0)).toFixed(2) },
    real: { investedUsd: +sumInvReal.toFixed(2), cashUsd: +Number(st.real.cash||0).toFixed(2), totalUsd: +(sumInvReal + Number(st.real.cash||0)).toFixed(2) }
  };

  // posiciones + botones + header
  const out = open
    .sort((a,b)=>Number(b.openedAt||0)-Number(a.openedAt||0))
    .slice(0, 10)
    .map(p=>{
      const price = px.get(p.mint) || 0;
      const pnl   = posPnl(p, price);
      const buttons = buttonsFor(p, price);
      return {
        id: p.id,
        mint: p.mint,
        symbol: String(p.symbol||'TOKEN').slice(0,12).toUpperCase(),
        mode,
        entryPriceUsd: Number(p.entryPriceUsd||0),
        priceNowUsd: Number(price||0),
        investedUsd: Number(p.investedUsd||0),
        pnlUsd: +pnl.usd.toFixed(2),
        pnlPct: +pnl.pct.toFixed(1),
        openedAt: Number(p.openedAt||0),
        isOpen: true,
        links: {
          dexscreener: `https://dexscreener.com/solana/${p.mint}`,
          solscan:     `https://solscan.io/token/${p.mint}`,
          jupiter:     `https://jup.ag/swap/SOL-${p.mint}`,
          raydium:     `https://raydium.io/swap/?inputCurrency=sol&outputCurrency=${p.mint}`
        },
        buttons
      };
    });

  const selectedId = out[0]?.id || null;
  const header = selectedId
    ? (()=>{ const s = out[0]; return { symbol: s.symbol, pnlText: `${s.pnlUsd>=0?'+':''}${fmtUsd(s.pnlUsd)} (${fmtPct(s.pnlPct)})` }; })()
    : { symbol: '-', pnlText: '$0.00 (+0.0%)' };

  return {
    ts: now(),
    mode,
    refreshMs: WALLET_REFRESH_MS,
    balances,
    positions: out,
    selectedId,
    header
  };
}

function writeJson(res, code, obj){
  const body = JSON.stringify(obj);
  res.writeHead(code, { 'content-type':'application/json', 'cache-control':'no-store', 'access-control-allow-origin':'*' });
  res.end(body);
}

function allowCORS(req, res){
  if (req.method==='OPTIONS'){
    res.writeHead(204, {
      'access-control-allow-origin':'*',
      'access-control-allow-methods':'GET,POST,OPTIONS',
      'access-control-allow-headers':'content-type,x-action-id'
    });
    res.end(); return true;
  }
  return false;
}

const srv = http.createServer(async (req, res)=>{
  try{
    if (allowCORS(req,res)) return;

    const u = url.parse(req.url, true);
    const path = u.pathname || '/';

    if (req.method==='GET' && path==='/api/wallet'){
      const mode = (u.query.mode==='real') ? 'real' : 'demo';
      const data = await computeWallet(mode);
      return writeJson(res, 200, data);
    }

    if (req.method==='POST' && path==='/api/sell'){
      const body = await jsonBody(req);
      const mode = (body.mode==='real') ? 'real' : 'demo';
      const posId = String(body.posId||'');
      const pct   = Math.max(1, Math.min(100, Number(body.pct||0)));

      const actionId = req.headers['x-action-id'] ? String(req.headers['x-action-id']) : null;
      const t = now();
      if (actionId){
        const seen = IDEMP.get(actionId);
        if (seen && (t - seen) < 60_000){
          const wallet = await computeWallet(mode);
          return writeJson(res, 200, { ok:true, dedup:true, wallet });
        }
        IDEMP.set(actionId, t);
      }

      if (!posId) return writeJson(res, 400, { ok:false, error:'posId requerido' });

      if (LOCKS.get(posId) && (t - LOCKS.get(posId)) < 5000){
        const wallet = await computeWallet(mode);
        return writeJson(res, 409, { ok:false, error:'lock', wallet });
      }
      LOCKS.set(posId, t);

      try{
        const st = loadState();
        st.positions = st.positions || {};
        const arr = Array.isArray(st.positions[mode]) ? st.positions[mode] : [];
        const pos = arr.find(p=>p.id===posId && p.isOpen!==false);
        if (!pos) return writeJson(res, 404, { ok:false, error:'pos no encontrada' });

        const invBefore = Number(pos.investedUsd||0);
        const frac = pct/100;

        // precio actual
        let price = 0;
        try{ const r=await getPriceUSD(pos.mint); price=Number(r?.price||r||0); } catch{}

        // valor aproximado a liquidar
        const entry = Number(pos.entryPriceUsd||0);
        const pieceValue = (entry>0 && price>0) ? invBefore*frac*(price/entry) : invBefore*frac;

        pos.investedUsd = Math.max(0, invBefore * (1 - frac));

        // cash
        st[mode] = st[mode] || {};
        if (typeof st[mode].cash !== 'number') st[mode].cash = 0;
        st[mode].cash = Number(st[mode].cash||0) + Number(pieceValue||0);

        let residualClosed = false;
        if (pos.investedUsd < RESIDUAL_USD){
          st[mode].cash += Number(pos.investedUsd||0);
          pos.investedUsd = 0;
          pos.isOpen=false; pos.status='closed'; pos.closedAt=now();
          residualClosed = true;
        }

        saveState(st);
        const wallet = await computeWallet(mode);
        return writeJson(res, 200, { ok:true, filledUsd:+pieceValue.toFixed(2), residualClosed, wallet });
      } finally {
        setTimeout(()=>LOCKS.delete(posId), 3000);
      }
    }

    if (req.method==='GET' && path==='/api/salud'){
      const r = await runHealthChecks({ timeoutMs: 1500 });
      return writeJson(res, 200, r);
    }

    return writeJson(res, 404, { ok:false, error:'not_found' });
  } catch(e){
    return writeJson(res, 500, { ok:false, error:String(e?.message||e) });
  }
});

srv.listen(PORT, '0.0.0.0', ()=>{
  console.log(`üåê API escuchando en http://0.0.0.0:${PORT}`);
});
