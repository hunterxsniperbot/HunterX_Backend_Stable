// import { wireCandidatos } from "./src/bot/wireCandidatos.js";
import "./src/boot/ipv4.js";
// index.js ‚Äî Entry point HunterX (ESM, robusto)
// 1) ENV + sane defaults
import "dotenv/config";
import { setDefaultResultOrder } from "node:dns";
setDefaultResultOrder("ipv4first");

// 2) Boot de infraestructura (no dependen de Telegram)
import "./src/boot/errors.js";   // opcional: captura errores no fatales
import "./src/boot/http.js";     // keep-alive / ajustes HTTP (si lo us√°s)
import "./src/boot/prewarm.js";  // pre-carga ligera (si lo us√°s)
import "./src/boot/api.js";      // <- expone /api/salud, /api/wallet, /api/sell
import { hookTyping } from "./src/boot/typing.js"; // indicador "typing..." (opcional)

// 3) Servicios para inyecci√≥n
import * as quickNodeClient from "./src/services/quicknode.js";
import * as phantomClient   from "./src/services/phantom.js";
import * as trading         from "./src/services/trading.js";

// 4) Handlers de comandos
import registerAjustes     from "./src/commands/ajustes.js";
import registerSniperReset from "./src/commands/sniperReset.js";
import registerAutoSniper  from "./src/commands/autoSniper.js";
import registerInlinePnlSell from "./src/bot/inlinePnlSell.js";
import registerMensaje     from "./src/commands/mensaje.js";
import attachWalletSell    from "./src/commands/wallet_sell.js";
import registerRegistro    from "./src/commands/registro.js";
import registerWallet      from "./src/commands/wallet.js";
import registerStatus      from "./src/commands/status.js";
import registerInitSheets  from "./src/commands/initSheets.js";
import registerPick        from "./src/commands/pick.js";
import registerMode        from "./src/commands/mode.js";
import registerSalud       from "./src/commands/salud.js";     // /salud
import registerDemoBuy     from "./src/commands/demo_buy.js";  // compra demo

// 5) Telegram (opcional: si no hay token, seguimos s√≥lo con la API)
import TelegramBot from "node-telegram-bot-api";

if (global.__HX_STARTED__) {
  console.log("‚ö†Ô∏è Bot ya hab√≠a iniciado (evito doble bootstrap)");
} else {
  global.__HX_STARTED__ = true;
}

let bot = global.__HX_BOT__;
const TOKEN = process.env.TELEGRAM_BOT_TOKEN;

if (!TOKEN) {
  console.warn("üü° TELEGRAM_BOT_TOKEN no configurado ‚Äî API arriba, Telegram deshabilitado.");
} else {
  if (!bot) {
    bot = new TelegramBot(TOKEN, { polling: { interval: 100, params: { timeout: 10 } } });
    hookTyping(bot);
    global.__HX_BOT__ = bot;

    bot.on("polling_error", (e) => {
      const m = String(e?.message || e || "");
      if (m.match(/EFATAL|ETIMEDOUT|ECONNRESET|ECONNABORTED|ENOTFOUND/)) {
        console.log("üåê [polling] aviso:", m);
      } else {
        console.error("‚ùå [polling_error]", m);
      }
    });
    console.log("üõ∞Ô∏è [TG] Modo: POLLING");
  }

  // Men√∫ slash
  async function setSlashMenu() {
    const commands = [
  { command: "salud",     description: "Conexiones activas" },
  { command: "autosniper",description: "Activar sniper autom√°tico" },
  { command: "real",      description: "Modo (Trading real)" },
  { command: "demo",      description: "Modo (simulaci√≥n)" },
  { command: "stop",      description: "Detener sniper" },
  { command: "wallet",    description: "Ver posiciones abiertas" },
  { command: "registro",  description: "Ver posiciones cerradas" },
  { command: "ajustes",   description: "Configurar sniper" },
  { command: "mensaje",   description: "Ayuda" }
];
    try {
      // if (process.env.SET_COMMANDS_ON_BOOT==="1") if (process.env.SET_COMMANDS_ON_BOOT==="1") if (process.env.SET_COMMANDS_ON_BOOT==="1") await bot.setMyCommands(commands, { scope: { type: "default" } });
      console.log("üü¶ [Slash] comandos seteados");
    } catch (e) {
      console.error("‚ùå setMyCommands:", e?.message || e);
    }
  }

  // Limpieza de teclados heredados
  bot._kbCleanAt = bot._kbCleanAt || {};
  bot.on("message", async (msg) => {
    try {
      if (msg.via_bot || msg.reply_to_message) return;
      const chatId = msg.chat.id;
      const last = bot._kbCleanAt[chatId] || 0;
      if (Date.now() - last < 60_000) return;
      await bot.sendMessage(chatId, " ", { reply_markup: { remove_keyboard: true } });
      bot._kbCleanAt[chatId] = Date.now();
    } catch {}
  });

  // Registro de handlers (una vez)
  if (!global.__HX_HANDLERS_REGISTERED__) {
    console.log("üîß Iniciando bot‚Ä¶");
    try { registerAjustes(bot, { quickNodeClient, phantomClient }); console.log("‚úÖ ajustes.js"); }          catch(e){ console.error("‚ùå ajustes:", e?.message||e); }
    try { registerSniperReset(bot);                                  console.log("‚úÖ sniperReset.js"); }     catch(e){ console.error("‚ùå sniperReset:", e?.message||e); }
    try { registerAutoSniper(bot, { quickNodeClient, phantomClient, trading }); console.log("‚úÖ autoSniper.js"); } catch(e){ console.error("‚ùå autoSniper:", e?.message||e); }
  try { registerInlinePnlSell(bot); console.log("‚úÖ inlinePnlSell.js"); }
  catch(e){ console.error("‚ùå inlinePnlSell:", e?.message||e); }
    try { registerWallet(bot, { quickNodeClient, phantomClient, trading });     console.log("‚úÖ wallet.js"); }      catch(e){ console.error("‚ùå wallet:", e?.message||e); }
    try { registerRegistro(bot, { trading });                         console.log("‚úÖ registro.js"); }       catch(e){ console.error("‚ùå registro:", e?.message||e); }
    try { registerMensaje(bot);                                       console.log("‚úÖ mensaje.js"); }        catch(e){ console.error("‚ùå mensaje:", e?.message||e); }
    try { attachWalletSell(bot);                                      console.log("‚úÖ wallet_sell.js"); }    catch(e){ console.error("‚ùå wallet_sell:", e?.message||e); }
    try { registerStatus(bot);                                        console.log("‚úÖ status.js"); }         catch(e){ console.error("‚ùå status:", e?.message||e); }
    try { registerInitSheets(bot);                                    console.log("‚úÖ initSheets.js"); }     catch(e){ console.error("‚ùå initSheets:", e?.message||e); }
    try { registerPick(bot);                                          console.log("‚úÖ pick.js"); }           catch(e){ console.error("‚ùå pick:", e?.message||e); }
    try { registerMode(bot);                                          console.log("‚úÖ mode.js"); }           catch(e){ console.error("‚ùå mode:", e?.message||e); }

    // extras
    try { registerSalud(bot);                                        console.log("‚úÖ salud.js"); }           catch(e){ console.error("‚ùå salud:", e?.message||e); }
    try { registerDemoBuy(bot);                                      console.log("‚úÖ demo_buy.js"); }        catch(e){ console.error("‚ùå demo_buy:", e?.message||e); }

    // NUEVO: comandos inline
    try { 
      const { default: registerComandosInline } = await import("./src/commands/comandos_inline.js"); 
      registerComandosInline(bot); 
      console.log("‚úÖ comandos_inline.js"); 
    } catch(e){ 
      console.error("‚ùå comandos_inline:", e?.message||e); 
    }

    // (menu) deshabilitado: usar BotFather
    global.__HX_HANDLERS_REGISTERED__ = true;
    console.log("ü§ñ HunterX Bot arrancado y escuchando comandos");
  } else {
    console.log("‚ö†Ô∏è Handlers ya estaban registrados (evito duplicar)");
  }

  // Atajo /discord (por si no hay handler dedicado)
  bot.onText(/^\/discord$/, (msg) => {
    bot.sendMessage(
      msg.chat.id,
      "üëæ Discord tendencias: https://discord.gg/tu-invite",
      { disable_web_page_preview: true }
    ).catch(()=>{});
  });
}

// Fin: si s√≥lo quer√©s API (sin token), ya qued√≥ arriba con /api/salud

// === wire /candidatos ===
try { wireCandidatos(bot); } catch {}
